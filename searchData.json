[{"title":"Note","url":"/2019/04/13/课堂笔记/","content":"\n\nhttp服务器\n\n## http协议简单介绍以及这部分内容学完我们能做什么？\n打开谷歌浏览器，输入www.taobao.com 网址就变成了https://www.taobao.com\nhttp协议：超文本传输协议，通俗理解，就是规定浏览器和服务器之间传输数据的的协议\n\n制作者：蒂姆·伯纳斯-李\n发展史：http/1.0版本  都是用的短连接\nhttp/1.1版本  使用的就是长连接\n\n## 浏览器访问的过程\n\n见图\n\n## 浏览器和服务器通信方式TCP\n## 目标:\n1.浏览器是客户端\n2.服务器是服务器端\n\n验证：\n把浏览器作为客户端，使用网络调试助手模拟TCP服务器端 \n把tcp服务器端的地址设定为127.0.0.1 端口为8080，我们http协议默认的端口就是80\n总结：\n1.浏览器底层就是tcp客户端\n2.web服务器端底层就是tcp服务器端\n\n工作经验:我们如果去写浏览器，但是浏览器都是一些大公司做的，你写的谁用，小公司，客户人数太少\n\n## 域名的介绍\n\n我们之前说了浏览器底层就是tcp客户端，那么客户端访问服务器端是不是需要端口和ip\n\n我们输入www.taobao.com它不是个ip地址，它成为域名\n\nping www.baidu.com  我们就可以看到百度的ip地址了\n早起美国网络起源时，会将一个域名对应一个ip地址。类似于我们的电话簿\n\ndns服务器，就负责解析域名对应的ip地址\n\n\nwww.baidu.com  --> ip http://14.215.177.39/\n扩展:我们将来买一个服务器给你一个ip地址，你也可以去买一个域名，和ip进行一个绑定\n\n总结:\n域名的作用:能够将ip地址进行解析，方便用户能够记忆\n\n## 请求与响应\n\n我们要根据不同的地址返回不同的页面，就要清楚的知道请求的时候携带的一些信息\n\n详解请求的数据\n\n## 请求的地址\n输入127.0.0.1:8080\n查看网络调试助手中的信息\n请求行格式: 请求的方式 空格 请求的地址 空格 http协议的版本\nGET / HTTP/1.1\n如果请求时不输入具体的网页地址，默认是/\n\n输入127.0.0.1:8080/index.html\nGET /index.html HTTP/1.1\n\n## 请求的2种方式\n\n1.get请求方式\n```\nGET /index.html HTTP/1.1 \nHost: 127.0.0.1:8080\nConnection: keep-alive\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36\nAccept-Encoding: gzip, deflate, sdch\nAccept-Language: zh-CN,zh;q=0.8\n\n\n```\nget方式的请求格式\n1.请求行\n2.请求头\n\n2.post请求方式\n```\nPOST / HTTP/1.1\nHost: 127.0.0.1:8080\nConnection: keep-alive\nContent-Length: 24\nCache-Control: max-age=0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\nOrigin: null\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36\nContent-Type: application/x-www-form-urlencoded\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.8\n\nname=zhangsan&pwd=123456\n```\npost请求方式的格式\n1.请求行\n2.请求头\n3.空行\n4.请求体\n\n总结：\n\n请求数据的结构：\n1.请求行\n\t1.1请求方式;\n\t\t1.get  一般输入地址，就是get方式\n\n\t\t2.post  (简单了解) 我们提交一些数据时比如注册，登录这种请求就是post请求方式\n\t1.2 请求的具体地址\n\t\t如果只请求 127.0.0.1  这个就是/ 根目录\n\t\t如果请求的是 127.0.0.1/index.html     /index.html 就是具体的请求地址\n\t\n\t1.3 http版本号 我们现在都是用的http1.1协议\n\n2.其余的是请求头\n3.空行\n4.请求体（get请求方式没有请求体，只有post请求方式有请求体，需要提交数据）\n\n总结: 请求行     请求方式 空格隔开 请求的具体地址 空格隔开 http协议版本\n\n## 请求头详解\n```\nPOST / HTTP/1.1 请求行\nHost: 127.0.0.1:8080  主机地址 ip端口\nConnection: keep-alive 长链接 http1.1版本都是长链接\nContent-Length: 24 接收的数据长度  我们现在都是长链接，怎么判断客户端是否断开了呢，就可以根据长度判断，客户端说明发送的数据长度，我接收到了这个长度的数据，就说明客户端发送一次数据结束\nCache-Control: max-age=0 缓存数据保存时间  生命周期\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 接收的数据类型\nOrigin: null  \nUpgrade-Insecure-Requests: 1  这个两个都是和我们cache缓存相关的\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36 浏览器版本信息头 这是一个反爬的手段，判断这个头，知道是否是浏览器请求的数据，还是爬虫去爬取我的数据  \nContent-Type: application/x-www-form-urlencoded  发送的数据格式 html  text 文本\nAccept-Encoding: gzip, deflate 允许接收压缩格式的文件，为了浏览器快速去解析内容\nAccept-Language: zh-CN,zh;q=0.8 浏览器能够理解的语言 中文\n\nname=zhangsan&pwd=123456\n```\n\n重点掌握 User-Agent 浏览器版本信息头\n\n## 请求总结：\n完善图\n\n## tcp服务器端接收浏览器请求的数据\n\n## 响应的格式\n\n1.体验响应效果\n\n```\nHTTP/1.1 200 ok     HTTP/1.1 404 not found\ncontent-length:4\n\nhello world\n```\n2.响应数据详解：\n1.响应行  HTTP/1.1 200 ok\n2.响应头 content-length:4\n3.空行 \n4.响应内容 hello world\n\n3.使用开发者工具查看响应数据信息 \n\n\n## 响应行中的状态码的介绍\n状态码的作用:浏览器向服务器发送了请求，那么服务器就要响应数据给它，状态码就代表响应的状态\n一般是给我们程序员看到\n1.200 ok  成功返回响应的数据\n2.303 重定向 跳转链接\n3.404 not found  一般是请求地址错误\n4.500 一般是服务器出现了故障\n\n总结：重点掌握 200 404\n\n## 响应头的介绍\n1.content-length  响应数据的长度\n2.content-type: text/html; charset=utf-8\n```\nHTTP/1.1 200 ok\n\nhello world\n```\n这样浏览器不会接受到数据，必须关闭服务器才能接受到，我们正常服务器是不会主动关闭的，所以需要说明我们发送的数据的长度\n```\nHTTP/1.1 200 ok\ncontent-length:100\n\nhello world\n```\n\n\n\n\n```\nHTTP/1.1 200 ok\ncontent-length:100\n\n我是中国人\n```\n这样的响应数据，浏览器会乱码，我们发送响应体是中文，所有要设置浏览器能够知道的编码\n```\nHTTP/1.1 200 ok\ncontent-type:text/html;charset=utf-8\ncontent-length:100\n\n我是中国人\n```\n\n## 响应总结\n完善图\n\n## tcp服务器接收发送数据给浏览器\n## 完整的浏览器访问服务器的过程\n总结\n\n## 调式工具\nF12 开发者工具\n\n## http课件内容回顾\n1.http是基于tcp的基础之上的  \n在传输层  网络通信 有两个方式 udp、tcp\n\n2.报文的理解，报纸 文章\n\n## 长连接和短连接\n\n目标：\n1.知道http1.0是使用的短连接\n2.知道http1.1是使用长连接\n3.知道长连接和短连接的区别\n\n案例:\n1. 短连接好比是单程票 一次请求和响应就断开浏览器客户端\n2.长连接好比是一卡通，可以实现多次来回的请求和响应，直到客户端没有数据发送，断开连接\n\n总结:\n1.短连接的特点：减少资源的占用，但是减慢了访问的速度\n2.长连接的特点：提高访问的速度，增加服务器端的资源的开销\n\n###http服务器（返回固定的数据）\n####目标:\n1.http服务器就是tcp服务器\n2.http服务器响应数据的格式\n\t1. 响应行\n\t2. 响应头\n\t3. 空行\n\t4. 响应体\n3.换行回车  \\r\\n \n\n####案例:写一个返回固定数据的http服务器\n\n####步骤:\n1.初始化socket\n2.端口复用，绑定端口和ip地址\n3.监听模式\n4.循环接受用户的请求\n5.处理用户的请求\n\t5.0.接收用户的发送的数据\n\t5.1响应行\n\t5.2响应头\n\t5.3空行\n\t5.4响应体\n\t5.5发送响应数据\n\t5.6.关闭客户端套\n6.关闭套接字\n\n####总结:\n1.http服务器基于tcp\n2.响应数据，换行回车  \\r\\n \n\n响应数据的格式:\n1. 响应行\n2. 响应头\n3. 空行\n4. 响应体\n\n### 获取http请求数据中的地址(正则)\n####目标\n1.请求报文的格式:\n请求行\n请求头\n空行\n请求体\n\n2.服务器接收浏览器发送的数据，解析里的地址\n3. 请求行的格式\nGET 空格 地址 空格 http版本\nGET / http/1.1\n\n####案例\n浏览器向服务器发送数据，解析请求数据中的地址,如果地址正确发送响应报文\n\n####步骤\n1.初始化socket\n2.端口复用，绑定端口和ip地址\n3.监听模式\n4.循环接受用户的请求\n5.处理用户的请求\n\t5.0.接收用户的发送的数据\n\t5.1.使用正则匹配地址\n\t5.2.组装响应报文\n\t5.3.发送数据给浏览器\n\t5.4.关闭客户端套接字\n\n6.关闭客户端套\n\n\n```\nimport socket\nimport re\n\n\ndef handle_client(client):\n    \"处理用户的请求\"\n    data = client.recv(1024).decode('utf-8')\n    print(data) # GET /index.html HTTP/1.1\n\n    # ret = re.match(\"[^/]+(/.*?)\\s\", data)\n    ret = re.match(\"[^/]+(/[^ ]*)\\s\", data)\n\n    if ret:\n        path = ret.group(1)\n        \n    else:\n        client.close()\n        return\n\n    if path == \"/index.html\":\n        response_line = \"HTTP/1.1 200 ok\\r\\n\"\n        response_header = \"content-type:text/html;charset=utf-8\\r\\n\"\n        response_none = \"\\r\\n\"\n        response_body = \"欢迎来到王者荣耀\"\n        response = response_line + response_header + response_none + response_body\n\n        client.send(response.encode('utf-8'))\n\n        client.close()\n\ndef main():\n    \"主函数\"\n    # 1.创建套接字\n    tcp_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    # 端口释放需要时间，0-4分钟之间，设置端口可以复用\n    tcp_server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)\n    # 2.绑定地址\n    tcp_server.bind((\"\", 8080)) # 绑定的地址是一个元组，第一个是ip,字符串类型，第二个是port，数字类型\n\n    # 3.监听模式\n    tcp_server.listen(128) # 128同一时间允许接受的最大客户端数\n\n    # 4.循环接受客户端的请求\n    while True:\n        client_socket, addr = tcp_server.accept() # client_socket专门为客户端服务的套接字\n        print(\"专门为你服务的套接字是:\", client_socket)\n        print(\"客户端的地址是:\", addr)\n\n        # 5.处理客户端的请求\n        handle_client(client_socket)\n\n    # 6.关闭套接字\n    tcp_server.close()\n\nif __name__ == '__main__':\n    main()\n```\n\n####总结:\n1.匹配地址正则表达式\nre.match(r\"[^/]+(/[^ ]*)\\s\").group(1)\n\n2.响应报文格式\n响应行\n响应头\n空行\n响应体\n\n### 课堂作业\n1.浏览器输入/,返回首页\n2.浏览器输入/index.html 返回首页\n3.浏览器输入/login.html 返回登陆\n4.浏览器输入register.html 返回注册\n5.浏览器输入其他，返回网页已走失，响应行中状态码为400 NOT FOUND\n\n### 作业讲解\n```\nimport socket\nimport re\n\ndef handle_client(client):\n    # 接受用户的数据\n    data = client.recv(1024).decode(\"utf-8\")\n    print(data)\n    ret = re.match(r\"[^/]+(/[^ ]*)\\s\", data) # '[^/]+(/[^ ]*) '\n    if ret:\n    \tfile_path = ret.group(1)\n    \t# print(1111111111,file_path)\n\t    if file_path == '/':\n\t        file_path = '/index.html'\n    else:\n        client.close()\n        return\n\n    # 响应行\n    response_line = \"HTTP/1.1 200 ok\\r\\n\"\n    # 响应头\n    response_header = \"content-type:text/html;charset=utf-8\\r\\n\"\n    # 空行\n    response_None = \"\\r\\n\"\n\n    if file_path == '/index.html':\n\n        # 响应体\n        response_body = \"欢迎来到王者荣耀\"\n\n    elif file_path == \"/login.html\":\n        # 响应数据\n        # 响应体\n        response_body = \"登录\"\n\n    elif file_path == \"/register.html\":\n        # 响应数据\n        response_body = \"注册\"\n    else:\n        # 响应数据\n        response_line = \"HTTP/1.1 400 NOT FOUND\\r\\n\"\n        response_body = \"网页已经走失\"\n\n\n    response = response_line + response_header + response_None + response_body\n\n    client.send(response.encode('utf-8'))\n    # 关闭客户端套接字\n    client.close()\n\n\ndef main():\n\n\n    # 初始化socket\n    tcp_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    # 端口复用，绑定端口和ip地址\n    tcp_server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)\n    tcp_server.bind((\"\", 8080))\n\n    # 监听模式\n\n    tcp_server.listen(128)\n    # 循环接受用户的请求\n    while True:\n        client_socket, address = tcp_server.accept()\n        # 处理用户的请求\n        handle_client(client_socket)\n\n    # 关闭套接字\n\n    tcp_server.close()\nif __name__ == '__main__':\n    main()\n```\n\n### 返回一个网页\n\n#### 目标\n1.我们已经能够返回固定的数据了，接下来我们返回一个完整的网页\n2.当网页中还有图片时，也是要发送请求的\n\n请求的资源有\n1./post.html\n2./favicon.ico\n3.images/1.png\n4.images/2.png\n5.images/3.png\n\n#### 案例\n浏览器发送请求，服务器返回一个网页\n\n#### 步骤\n1.初始化socket\n2.端口复用，绑定端口和ip地址\n3.监听模式\n4.循环接受用户的请求\n5.处理用户的请求\n\t5.0.接收用户的发送的数据\n\t5.1.使用正则匹配地址\n\t5.2.组装响应报文（不返回文字，返回一个网页）\n\t\t返回的post.html里有图片，图片也需要响应\n\t\t/favicon.ico也需要处理\n\t5.3.发送数据给浏览器\n\t5.4.关闭客户端套接字\n\n6.关闭服务端套接字\n\n#### 代码\n```\n# 初始化套芥子\n# 绑定端口，复用\n# 监听套芥子\n# 循环接受用户的请求\n# 处理用户的请求\nimport threading\nimport socket\nimport re\n\nimport time\n\n\ndef handle_client(client):\n    time.sleep(5)\n    data = client.recv(1024).decode(\"utf-8\")\n\n    ret = re.match(r\"[^/]+(/[^ ]*)\\s\", data)\n    if ret:\n        file_path = ret.group(1)\n        if file_path == \"/\":\n            file_path = \"/post.html\"\n    else:\n        client.close()\n        return\n\n\n    with open(\"static%s\"%file_path, 'rb') as f:\n        data = f.read()\n\n    response_line = \"HTTP/1.1 200 ok\\r\\n\".encode('utf-8')\n    response_header = \"content-type:text/html;charset=utf-8\\r\\n\".encode(\"utf-8\")\n    response_None = \"\\r\\n\".encode(\"utf-8\")\n    response_body = data\n    response = response_line + response_header + response_None +response_body\n    client.send(response)\n\n    client.close()\n    print(11111)\n\ndef main():\n\n\n    # 初始化套芥子\n    tcp_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    # 绑定端口，复用\n    tcp_server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)\n    tcp_server.bind(('', 8080))\n\n    # 监听套芥子\n    tcp_server.listen(128)\n    while True:\n        # 循环接受用户的请求\n\n        client, address = tcp_server.accept()\n        # threading.Thread(target=handle_client, args=(client,)).start()\n        # 处理用户的请求\n\n        handle_client(client)\n\n\n\n\nif __name__ == '__main__':\n    main()\n\n```\n\n#### 总结\n\n1.打开文件内容，返回里面的数据\n2.如果网页中有图片，也是会发送请求，我们需要将图片的数据响应\n\n\n### http服务器面向对象版\n#### 目标\n1.tcp的准备工作代码\n\t1.初始化socket\n\t2.端口复用，绑定端口和ip地址\n\t3.监听模式\n2.核心代码\n\t1.循环接受用户的请求\n\t2.处理用户的请求\n\t3.关闭服务器端socket\n3.处理用户请求的代码\n\t3.1接收用户的发送的数据\n\t3.2响应行\n\t3.3响应头\n\t3.4空行\n\t3.5响应体\n\t3.6发送响应数据\n\t3.7.关闭客户端套\n\n#### 案例\n1.将面向过程改为面向对象版的http服务器\n\n#### 步骤\n1.定义个Tcp_Server类\n2.将tcp服务器的准备工作放到init方法中，全部设置为属性\n3.将核心代码放到run_server方法中\n4.将处理用户请求的代码抽取为一个方法\n\ntcp_server = Tcp_Server()\ntcp_server.run_server()\n\n\n\n```   \nimport socket\nimport re\n\nimport time\n\n\nclass Tcp_Server(object):\n    def __init__(self):\n        # 1.初始化socket\n        self.tcp_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n        # 2.端口复用，绑定端口和ip地址\n        self.tcp_server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)\n        self.tcp_server.bind((\"\", 8080))\n        # 3.监听模式\n        self.tcp_server.listen(128)\n\n    def run_server(self):\n        while True:\n            client, address = self.tcp_server.accept()\n\n            # 5.处理用户的请求\n            self.handle_client(client)\n\n        # 6.关闭客户端套\n        tcp_server.close()\n\n    def handle_client(self, client):\n        time.sleep(4)\n\n        # 5.0.接收用户的发送的数据\n        data = client.recv(1024).decode(\"utf-8\")\n        ret  = re.match(r\"[^/]+(/[^ ]*)\\s\", data)\n        if ret:\n            file_path = ret.group(1)\n            if file_path == \"/\":\n                file_path = \"/post.html\"\n        else:\n            client.close()\n            return\n        print(file_path)\n\n\n        # 响应行\n        response_line = \"HTTP/1.1 200 ok\\r\\n\"\n\n        # 响应头\n        response_header = \"content-type:text/html;charset=utf-8\\r\\n\"\n\n        # 空行\n        response_None = \"\\r\\n\"\n\n        with open('static%s'%file_path, 'rb')as f:\n            content = f.read()\n        response_body = content\n\n        response = response_line.encode('utf-8') + response_header.encode('utf-8') + response_None.encode('utf-8') + response_body\n        client.send(response)\n        client.close()\n\n\n\ndef main():\n\n    tcp_server = Tcp_Server()\n    tcp_server.run_server()\n    # 4.循环接受用户的请求\n\n\nif __name__ == '__main__':\n    main()\n```\n\n####总结\n\n\n\n### http服务器多任务版\n####目标:\n1.多线程\n2.多进程\n3.协程\n如果图片同时出现，说明是多任务\n\n####案例:\n将http服务器面向对象版改为多任务版\n网页中有三种图片，需要同时发送请求\n\n####步骤\n1.多线程\n1.导入模块 threading\n2.处理客户端请求为耗时任务，添加到多线程任务\n3.开启线程\n\n2.多进程\n1.导入模块 multiprocessing\n2.处理客户端请求为耗时任务，添加到多进程任务\n3.开启进程\n注意:在多进程中开启子进程，会把父进程的资源复制一份，所以我们开启多进程，就会有多个client客户端\n需要将client关闭\n\n3.协程\n1.导入模块 gevent\n2.请猴子 打补丁  \nfrom gevent import monkey \nmonkey.patch_all()\n\n3.处理客户端请求为耗时任务，添加到多协程任务\n4.加入到耗时列表\n注意:在协程中我们将任务添加到耗时列表，就是为了阻塞协程，\n但是在当前代码中，是while True，开启的，本身就是一个耗时任务，所以不需要加入耗时列表中\n\n\n#### 总结\n\n####代码\n#####多线程\n```\n# 初始化套芥子\n# 绑定端口，复用\n# 监听套芥子\n# 循环接受用户的请求\n# 处理用户的请求\nimport threading\nimport socket\nimport re\n\nimport time\n\n\ndef handle_client(client):\n    time.sleep(5)\n    data = client.recv(1024).decode(\"utf-8\")\n\n    ret = re.match(r\"[^/]+(/[^ ]*)\\s\", data)\n    if ret:\n        file_path = ret.group(1)\n        if file_path == \"/\":\n            file_path = \"/post.html\"\n    else:\n        client.close()\n        return\n\n\n    with open(\"static%s\"%file_path, 'rb') as f:\n        data = f.read()\n\n    response_line = \"HTTP/1.1 200 ok\\r\\n\".encode('utf-8')\n    response_header = \"content-type:text/html;charset=utf-8\\r\\n\".encode(\"utf-8\")\n    response_None = \"\\r\\n\".encode(\"utf-8\")\n    response_body = data\n    response = response_line + response_header + response_None +response_body\n    client.send(response)\n\n    client.close()\n    print(11111)\n\ndef main():\n\n\n    # 初始化套芥子\n    tcp_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    # 绑定端口，复用\n    tcp_server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)\n    tcp_server.bind(('', 8080))\n\n    # 监听套芥子\n    tcp_server.listen(128)\n    while True:\n        # 循环接受用户的请求\n\n        client, address = tcp_server.accept()\n        threading.Thread(target=handle_client, args=(client,)).start()\n        # 处理用户的请求\n\n        # handle_client(client)\n\n\n\n\nif __name__ == '__main__':\n    main()\n```\n#####多进程\n```\n# 初始化套芥子\n# 绑定端口，复用\n# 监听套芥子\n# 循环接受用户的请求\n# 处理用户的请求\nimport multiprocessing\nimport threading\nimport socket\nimport re\n\nimport time\n\n\ndef handle_client(client):\n    time.sleep(5)\n    data = client.recv(1024).decode(\"utf-8\")\n\n    ret = re.match(r\"[^/]+(/[^ ]*)\\s\", data)\n    if ret:\n        file_path = ret.group(1)\n        if file_path == \"/\":\n            file_path = \"/post.html\"\n    else:\n        client.close()\n        return\n\n\n    with open(\"static%s\"%file_path, 'rb') as f:\n        data = f.read()\n\n    response_line = \"HTTP/1.1 200 ok\\r\\n\".encode('utf-8')\n    response_header = \"content-type:text/html;charset=utf-8\\r\\n\".encode(\"utf-8\")\n    response_None = \"\\r\\n\".encode(\"utf-8\")\n    response_body = data\n    response = response_line + response_header + response_None +response_body\n    client.send(response)\n\n    client.close()\n    print(11111)\n\ndef main():\n\n\n    # 初始化套芥子\n    tcp_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    # 绑定端口，复用\n    tcp_server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)\n    tcp_server.bind(('', 8080))\n\n    # 监听套芥子\n    tcp_server.listen(128)\n    while True:\n        # 循环接受用户的请求\n\n        client, address = tcp_server.accept()\n        multiprocessing.Process(target=handle_client, args=(client,)).start()\n        # threading.Thread(target=handle_client, args=(client,)).start()\n        # 处理用户的请求\n        client.close()\n\n        # handle_client(client)\n\n\n\n\nif __name__ == '__main__':\n    main()\n```\n##### 协程\n```\n# 初始化套芥子\n# 绑定端口，复用\n# 监听套芥子\n# 循环接受用户的请求\n# 处理用户的请求\nimport gevent\nfrom gevent import monkey\nmonkey.patch_all()\nimport multiprocessing\nimport threading\nimport socket\nimport re\n\nimport time\n\nimport gevent\n\n\ndef handle_client(client):\n    time.sleep(5)\n    data = client.recv(1024).decode(\"utf-8\")\n\n    ret = re.match(r\"[^/]+(/[^ ]*)\\s\", data)\n    if ret:\n        file_path = ret.group(1)\n        if file_path == \"/\":\n            file_path = \"/post.html\"\n    else:\n        client.close()\n        return\n\n\n    with open(\"static%s\"%file_path, 'rb') as f:\n        data = f.read()\n\n    response_line = \"HTTP/1.1 200 ok\\r\\n\".encode('utf-8')\n    response_header = \"content-type:text/html;charset=utf-8\\r\\n\".encode(\"utf-8\")\n    response_None = \"\\r\\n\".encode(\"utf-8\")\n    response_body = data\n    response = response_line + response_header + response_None +response_body\n    client.send(response)\n\n    client.close()\n    print(11111)\n\ndef main():\n\n\n    # 初始化套芥子\n    tcp_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    # 绑定端口，复用\n    tcp_server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)\n    tcp_server.bind(('', 8080))\n\n    # 监听套芥子\n    tcp_server.listen(128)\n    while True:\n        # 循环接受用户的请求\n\n        client, address = tcp_server.accept()\n        gevent.spawn(handle_client, client)\n        # multiprocessing.Process(target=handle_client, args=(client,)).start()\n        # threading.Thread(target=handle_client, args=(client,)).start()\n        # 处理用户的请求\n        # client.close()\n\n        # handle_client(client)\n    tcp_server.close()\n\n\n\n\nif __name__ == '__main__':\n    main()\n```\n\n### http服务器在程序外传参\n####目标\n需要掌握sys.argv知识\n\n1.我们的项目是最终放在服务器中的，没有图形化界面的，如果端口重复，会启动错误\n2.在程序外面传递端口号\n3.在终端运行python3 http服务器程序传参.py 8080启动程序\n\n####案例\n在终端运行python3 http服务器程序传参.py 8080  启动程序\n\n####步骤\n1.需要在程序在终端运行传递端口\n2.判断sys.argv的长度是否是2\n3.判断端口参数是否是纯数字\n4.将接收的端口信息转换成int类型，在创建程序时传递给init初始化\n\n####总结\n1.sys.argv可以在程序外传参是一个列表类型\n2.文件名是列表中的第一个元素\n\n\n####代码\n```\nimport multiprocessing\nimport socket\nimport threading\nimport gevent\nimport sys\nfrom gevent import monkey\nmonkey.patch_all()\nimport re\n\nimport time\n\n\ndef handle_client(client):\n    time.sleep(1)\n\n    data = client.recv(1024).decode(\"utf-8\")\n    print(data)\n    # 1.匹配地址\n    ret = re.match(r\"[^/]+(/[^ ]*)\\s\", data)\n    print(ret.group(1))\n    if ret:\n        file_path = ret.group(1)\n        if file_path == \"/\":\n            file_path = \"/post.html\"\n    else:\n        client.close()\n        return\n    print(file_path)\n    response_line = \"HTTP/1.1 200 ok\\r\\n\"\n    response_header = \"content-type:text/html;charset=utf-8\\r\\n\"\n    response_None = \"\\r\\n\"\n\n    if file_path == \"/post.html\":\n        with open(\"post.html\", 'r') as f:\n            content = f.read()\n        response_body = content\n        response = response_line + response_header + response_None + response_body\n        response = response.encode('utf-8')\n        client.send(response)\n    elif file_path == '/favicon.ico':\n        pass\n\n    else:\n        with open('.%s'%file_path, 'rb') as f:\n            content = f.read()\n        response_body = content\n        response = response_line.encode('utf-8') + response_header.encode('utf-8') + response_None.encode('utf-8') + response_body\n\n        client.send(response)\n    client.close()\n    # 组装响应报文\n\n\nclass Tcp_Server(object):\n    def __init__(self, port):\n        self.tcp_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.tcp_server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)\n        self.tcp_server.bind((\"\", port))\n        self.tcp_server.listen(128)\n\n    def run_server(self):\n        while True:\n            client, address = self.tcp_server.accept()\n            # threading.Thread(target=handle_client, args=(client,)).start()\n            # multiprocessing.Process(target=handle_client, args=(client,)).start()\n            gevent.spawn(handle_client, client)\n            # 这里不需要加入到耗时列表中，因为本身就是耗时的\n            # 需要关闭套接字\n            # handle_client(client)\n\n        self.tcp_server.close()\n\ndef main():\n    if len(sys.argv) != 2:\n        print(\"启动程序格式: python3 08.http服务器传参.py 8080\")\n        return\n    \n    if not sys.argv[1].isdigit():\n        print(\"启动程序格式: python3 08.http服务器传参.py 8080\")\n        return\n\n    port = sys.argv[1]\n    # print(type(port))\n    tcp_server = Tcp_Server(int(port))\n    tcp_server.run_server()\n\n\nif __name__ == '__main__':\n    main()\n```"},{"title":"redis集群搭建","url":"/2019/04/09/redis集群搭建/","content":"## redis集群搭建\n\n###### 集群的概念：集群是一组相互独立的、通过高速网络互联的计算机，它们构成了一个组，并以单一系统的模式加以管理。\n\n###### redis数据库准备：\n\n> 创建文件目录conf/7000.conf(有多少个服务器就键几个，ps:可以在不同机器上创建，主要区别是port、bing（真实主机IP）、pidfile、cluster-config-file)\n\n~~~\nport 7000\nbind 172.16.179.130\ndaemonize yes\npidfile 7000.pid\ncluster-enabled yes\ncluster-config-file 7000_node.conf\ncluster-node-timeout 15000\nappendonly yes\n~~~\n\n> 启动：redis-server 7000.conf（有几个就启动几个）\n\n> 查看进程是否启动：ps -ef | grep redis\n\n###### 创建集群\n\n1. redis的安装包中包含了redis-trib.rb，⽤于创建集群\n\n2. 接下来的操作在172.16.179.130（可以在集群内的任一机器上执行）机器上进⾏\n\n3. 将命令复制，这样可以在任何⽬录下调⽤此命令\n\n   ~~~\n   sudo cp /usr/share/doc/redis-tools/examples/redis-trib.rb /usr/local/bin/\n   ~~~\n\n4. 安装ruby环境，因为redis-trib.rb是⽤ruby开发的\n\n   ~~~\n   sudo apt-get install ruby\n   ~~~\n\n5. 运⾏如下命令创建集群（包含所有创建集群的redis程序）ps：集群会从参与集群的redis程序中选取不少于一半的程序作为主服务器（少于的话整个集群无法提供服务）\n\n   ~~~\n   redis-trib.rb create --replicas 1 172.16.179.130:7000 172.16.179.130:7001 172.16.179.130:7002 172.16.179.131:7003 172.16.179.131:7004 172.16.179.131:7005集群是\n   ~~~\n\n###### 数据怎么决定存在哪个redis上（CRC16）\n\n理解关键点：\n\n+ 去中心化、去中间件 负载均衡\n+ 哈希槽（hash slot）分配、默认16384个槽（solt）、具体算法CRC16(key) % 16384 如果有n个redis master，每个redis master均分16384个槽，而且是连续的\n+ Redis 集群会把数据存在⼀个 master 节点，然后在这个 master 和其对应的salve 之间进⾏数据同步。当读取数据时，也根据⼀致性哈希算法到对应的 master 节 点获取数据。只有当⼀个master 挂掉之后，才会启动⼀个对应的 salve 节点，充 当 master\n+ 需要注意的是：必须要3个或以上的主节点，否则在创建集群时会失败，并且当存 活的主节点数⼩于总节点数的⼀半时，整个集群就⽆法提供服务了\n\n###### redis cluster与python交互\n\n1. 安装依赖包\n\n   ~~~\n   pip install redis-py-cluster\n   ~~~\n\n2. 连接示例\n\n   ~~~python\n   from rediscluster import *\n   if __name__ == '__main__':\n   \ttry:\n       # 构建所有的节点，Redis会使⽤CRC16算法，将键和值写到某个节点上(连接的是集群里面的master节点)\n       startup_nodes = [\n           {'host': '192.168.26.128', 'port': '7000'},\n           {'host': '192.168.26.130', 'port': '7003'},\n           {'host': '192.168.26.128', 'port': '7001'},\n       ]\n       # 构建StrictRedisCluster对象                   \t  \tsrc=StrictRedisCluster(startup_nodes=startup_nodes,decode_responses=True)\n       # 设置键为name、值为itheima的数据\n       result=src.set('name','itheima')\n       print(result)\n       # 获取键为name\n       name = src.get('name')\n       print(name)\n     except Exception as e:\n       print(e)\n   ~~~\n\n   \n\n"}]