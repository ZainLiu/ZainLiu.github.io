[{"title":"python&&django连接redis sentinel集群（哨兵模式）","url":"/2019/12/31/python连接redis sentinel集群（哨兵模式）/","content":"## python 连接redis sentinel\n\n> 相关依赖包\n\n~~~python\nimport redis\nfrom redis.sentinel import Sentinel\n~~~\n\n> 连接哨兵服务器(主机名也可以用域名)\n\n~~~python\nsentinel = Sentinel([('172.31.0.2', 5001),\n('172.31.0.3', 5001),\n('172.31.0.4', 5001),\n('172.31.0.5', 5001)\n],\nsocket_timeout=0.5)\n~~~\n\n> 获取主服务器地址\n\n~~~python\nmaster = sentinel.discover_master('mymaster')\nprint(master)\n# 输出：('172.31.0.2', 5001)\n~~~\n\n> 获取从服务器地址\n\n~~~python\nslave = sentinel.discover_slaves('mymaster')\nprint(slave)\n# 输出：[('172.31.3', 5001), ('172.31.0.4', 5001), ('172.31.0.5', 5001)]\n~~~\n\n> 获取主服务器进行写入\n\n~~~python\nmaster = sentinel.master_for('mymaster', socket_timeout=0.5, password='redis_auth_pass', db=15)\nw_ret = master.set('foo', 'bar')\n# 输出：True\n~~~\n\n> 获取从服务器进行读取（默认是round-roubin）\n\n~~~python\nslave = sentinel.slave_for('mymaster', socket_timeout=0.5, password='redis_auth_pass', db=15)\nr_ret = slave.get('foo')\nprint(r_ret)\n# 输出：bar\n~~~\n\n## django连接redis sentinel\n\n### 方法一\n\n> 依赖包\n\n~~~\npip install django-redis-sentinel\n~~~\n\n> 配置信息\n\n~~~python\nCACHES = {\n        \"default\": {\n            \"BACKEND\": \"django_redis.cache.RedisCache\",\n            \"LOCATION\": \"redis_master/sentinel-host1:2639,sentinel-host2:2639/0\"\n            \"OPTIONS\": {\n                \"PASSWORD\": 's3cret_passw0rd!',\n                \"CLIENT_CLASS\": \"django_redis_sentinel.SentinelClient\",\n            }\n        }\n    }\n~~~\n\n> 配置例子\n\n~~~python\nCACHES = {\n    \"default\": {\n        \"BACKEND\": \"django_redis.cache.RedisCache\",\n        \"LOCATION\": [\n            \"redis://127.0.0.1:6379?db=1\",\n            \"redis://127.0.0.1:6379?db=1\",\n        ],\n        \"OPTIONS\": {\n            \"CLIENT_CLASS\": \"django_redis_sentinel.SentinelClient\",\n        }\n    },\n}\n~~~\n\n### 方法二（HA（high、available）：高可用版）\n\n> 依赖包(依赖方法一的包)\n\n~~~\npip install django-redis-sentinel\n~~~\n\n> 配置\n\n~~~python\nCACHES = {\n    \"default\": {\n        \"BACKEND\": \"django_redis_sentinel.cache.RedisSentinelCache\",\n        \"LOCATION\": [\n            (\"sentinel1\", 26379),  # 必须元组\n            (\"sentinel2\", 26379),\n            (\"sentinel3\", 26379)\n        ],\n        \"OPTIONS\": {\n            \"CLIENT_CLASS\": \"django_redis_sentinel.client.SentinelClient\",\n            \"SENTINEL_SERVICE_NAME\": \"rmaster\",\n            \"REDIS_CLIENT_KWARGS\": {\n                \"db\": 1\n            }\n        }\n    }\n}\n~~~\n\n"},{"title":"Note","url":"/2019/04/13/课堂笔记/","content":"\n\nhttp服务器\n\n## http协议简单介绍以及这部分内容学完我们能做什么？\n打开谷歌浏览器，输入www.taobao.com 网址就变成了https://www.taobao.com\nhttp协议：超文本传输协议，通俗理解，就是规定浏览器和服务器之间传输数据的的协议\n\n制作者：蒂姆·伯纳斯-李\n发展史：http/1.0版本  都是用的短连接\nhttp/1.1版本  使用的就是长连接\n\n## 浏览器访问的过程\n\n见图\n\n## 浏览器和服务器通信方式TCP\n## 目标:\n1.浏览器是客户端\n2.服务器是服务器端\n\n验证：\n把浏览器作为客户端，使用网络调试助手模拟TCP服务器端 \n把tcp服务器端的地址设定为127.0.0.1 端口为8080，我们http协议默认的端口就是80\n总结：\n1.浏览器底层就是tcp客户端\n2.web服务器端底层就是tcp服务器端\n\n工作经验:我们如果去写浏览器，但是浏览器都是一些大公司做的，你写的谁用，小公司，客户人数太少\n\n## 域名的介绍\n\n我们之前说了浏览器底层就是tcp客户端，那么客户端访问服务器端是不是需要端口和ip\n\n我们输入www.taobao.com它不是个ip地址，它成为域名\n\nping www.baidu.com  我们就可以看到百度的ip地址了\n早起美国网络起源时，会将一个域名对应一个ip地址。类似于我们的电话簿\n\ndns服务器，就负责解析域名对应的ip地址\n\n\nwww.baidu.com  --> ip http://14.215.177.39/\n扩展:我们将来买一个服务器给你一个ip地址，你也可以去买一个域名，和ip进行一个绑定\n\n总结:\n域名的作用:能够将ip地址进行解析，方便用户能够记忆\n\n## 请求与响应\n\n我们要根据不同的地址返回不同的页面，就要清楚的知道请求的时候携带的一些信息\n\n详解请求的数据\n\n## 请求的地址\n输入127.0.0.1:8080\n查看网络调试助手中的信息\n请求行格式: 请求的方式 空格 请求的地址 空格 http协议的版本\nGET / HTTP/1.1\n如果请求时不输入具体的网页地址，默认是/\n\n输入127.0.0.1:8080/index.html\nGET /index.html HTTP/1.1\n\n## 请求的2种方式\n\n1.get请求方式\n```\nGET /index.html HTTP/1.1 \nHost: 127.0.0.1:8080\nConnection: keep-alive\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36\nAccept-Encoding: gzip, deflate, sdch\nAccept-Language: zh-CN,zh;q=0.8\n\n\n```\nget方式的请求格式\n1.请求行\n2.请求头\n\n2.post请求方式\n```\nPOST / HTTP/1.1\nHost: 127.0.0.1:8080\nConnection: keep-alive\nContent-Length: 24\nCache-Control: max-age=0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\nOrigin: null\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36\nContent-Type: application/x-www-form-urlencoded\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.8\n\nname=zhangsan&pwd=123456\n```\npost请求方式的格式\n1.请求行\n2.请求头\n3.空行\n4.请求体\n\n总结：\n\n请求数据的结构：\n1.请求行\n\t1.1请求方式;\n\t\t1.get  一般输入地址，就是get方式\n\n\t\t2.post  (简单了解) 我们提交一些数据时比如注册，登录这种请求就是post请求方式\n\t1.2 请求的具体地址\n\t\t如果只请求 127.0.0.1  这个就是/ 根目录\n\t\t如果请求的是 127.0.0.1/index.html     /index.html 就是具体的请求地址\n\t\n\t1.3 http版本号 我们现在都是用的http1.1协议\n\n2.其余的是请求头\n3.空行\n4.请求体（get请求方式没有请求体，只有post请求方式有请求体，需要提交数据）\n\n总结: 请求行     请求方式 空格隔开 请求的具体地址 空格隔开 http协议版本\n\n## 请求头详解\n```\nPOST / HTTP/1.1 请求行\nHost: 127.0.0.1:8080  主机地址 ip端口\nConnection: keep-alive 长链接 http1.1版本都是长链接\nContent-Length: 24 接收的数据长度  我们现在都是长链接，怎么判断客户端是否断开了呢，就可以根据长度判断，客户端说明发送的数据长度，我接收到了这个长度的数据，就说明客户端发送一次数据结束\nCache-Control: max-age=0 缓存数据保存时间  生命周期\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 接收的数据类型\nOrigin: null  \nUpgrade-Insecure-Requests: 1  这个两个都是和我们cache缓存相关的\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36 浏览器版本信息头 这是一个反爬的手段，判断这个头，知道是否是浏览器请求的数据，还是爬虫去爬取我的数据  \nContent-Type: application/x-www-form-urlencoded  发送的数据格式 html  text 文本\nAccept-Encoding: gzip, deflate 允许接收压缩格式的文件，为了浏览器快速去解析内容\nAccept-Language: zh-CN,zh;q=0.8 浏览器能够理解的语言 中文\n\nname=zhangsan&pwd=123456\n```\n\n重点掌握 User-Agent 浏览器版本信息头\n\n## 请求总结：\n完善图\n\n## tcp服务器端接收浏览器请求的数据\n\n## 响应的格式\n\n1.体验响应效果\n\n```\nHTTP/1.1 200 ok     HTTP/1.1 404 not found\ncontent-length:4\n\nhello world\n```\n2.响应数据详解：\n1.响应行  HTTP/1.1 200 ok\n2.响应头 content-length:4\n3.空行 \n4.响应内容 hello world\n\n3.使用开发者工具查看响应数据信息 \n\n\n## 响应行中的状态码的介绍\n状态码的作用:浏览器向服务器发送了请求，那么服务器就要响应数据给它，状态码就代表响应的状态\n一般是给我们程序员看到\n1.200 ok  成功返回响应的数据\n2.303 重定向 跳转链接\n3.404 not found  一般是请求地址错误\n4.500 一般是服务器出现了故障\n\n总结：重点掌握 200 404\n\n## 响应头的介绍\n1.content-length  响应数据的长度\n2.content-type: text/html; charset=utf-8\n```\nHTTP/1.1 200 ok\n\nhello world\n```\n这样浏览器不会接受到数据，必须关闭服务器才能接受到，我们正常服务器是不会主动关闭的，所以需要说明我们发送的数据的长度\n```\nHTTP/1.1 200 ok\ncontent-length:100\n\nhello world\n```\n\n\n\n\n```\nHTTP/1.1 200 ok\ncontent-length:100\n\n我是中国人\n```\n这样的响应数据，浏览器会乱码，我们发送响应体是中文，所有要设置浏览器能够知道的编码\n```\nHTTP/1.1 200 ok\ncontent-type:text/html;charset=utf-8\ncontent-length:100\n\n我是中国人\n```\n\n## 响应总结\n完善图\n\n## tcp服务器接收发送数据给浏览器\n## 完整的浏览器访问服务器的过程\n总结\n\n## 调式工具\nF12 开发者工具\n\n## http课件内容回顾\n1.http是基于tcp的基础之上的  \n在传输层  网络通信 有两个方式 udp、tcp\n\n2.报文的理解，报纸 文章\n\n## 长连接和短连接\n\n目标：\n1.知道http1.0是使用的短连接\n2.知道http1.1是使用长连接\n3.知道长连接和短连接的区别\n\n案例:\n1. 短连接好比是单程票 一次请求和响应就断开浏览器客户端\n2.长连接好比是一卡通，可以实现多次来回的请求和响应，直到客户端没有数据发送，断开连接\n\n总结:\n1.短连接的特点：减少资源的占用，但是减慢了访问的速度\n2.长连接的特点：提高访问的速度，增加服务器端的资源的开销\n\n###http服务器（返回固定的数据）\n####目标:\n1.http服务器就是tcp服务器\n2.http服务器响应数据的格式\n\t1. 响应行\n\t2. 响应头\n\t3. 空行\n\t4. 响应体\n3.换行回车  \\r\\n \n\n####案例:写一个返回固定数据的http服务器\n\n####步骤:\n1.初始化socket\n2.端口复用，绑定端口和ip地址\n3.监听模式\n4.循环接受用户的请求\n5.处理用户的请求\n\t5.0.接收用户的发送的数据\n\t5.1响应行\n\t5.2响应头\n\t5.3空行\n\t5.4响应体\n\t5.5发送响应数据\n\t5.6.关闭客户端套\n6.关闭套接字\n\n####总结:\n1.http服务器基于tcp\n2.响应数据，换行回车  \\r\\n \n\n响应数据的格式:\n1. 响应行\n2. 响应头\n3. 空行\n4. 响应体\n\n### 获取http请求数据中的地址(正则)\n####目标\n1.请求报文的格式:\n请求行\n请求头\n空行\n请求体\n\n2.服务器接收浏览器发送的数据，解析里的地址\n3. 请求行的格式\nGET 空格 地址 空格 http版本\nGET / http/1.1\n\n####案例\n浏览器向服务器发送数据，解析请求数据中的地址,如果地址正确发送响应报文\n\n####步骤\n1.初始化socket\n2.端口复用，绑定端口和ip地址\n3.监听模式\n4.循环接受用户的请求\n5.处理用户的请求\n\t5.0.接收用户的发送的数据\n\t5.1.使用正则匹配地址\n\t5.2.组装响应报文\n\t5.3.发送数据给浏览器\n\t5.4.关闭客户端套接字\n\n6.关闭客户端套\n\n\n```\nimport socket\nimport re\n\n\ndef handle_client(client):\n    \"处理用户的请求\"\n    data = client.recv(1024).decode('utf-8')\n    print(data) # GET /index.html HTTP/1.1\n\n    # ret = re.match(\"[^/]+(/.*?)\\s\", data)\n    ret = re.match(\"[^/]+(/[^ ]*)\\s\", data)\n\n    if ret:\n        path = ret.group(1)\n        \n    else:\n        client.close()\n        return\n\n    if path == \"/index.html\":\n        response_line = \"HTTP/1.1 200 ok\\r\\n\"\n        response_header = \"content-type:text/html;charset=utf-8\\r\\n\"\n        response_none = \"\\r\\n\"\n        response_body = \"欢迎来到王者荣耀\"\n        response = response_line + response_header + response_none + response_body\n\n        client.send(response.encode('utf-8'))\n\n        client.close()\n\ndef main():\n    \"主函数\"\n    # 1.创建套接字\n    tcp_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    # 端口释放需要时间，0-4分钟之间，设置端口可以复用\n    tcp_server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)\n    # 2.绑定地址\n    tcp_server.bind((\"\", 8080)) # 绑定的地址是一个元组，第一个是ip,字符串类型，第二个是port，数字类型\n\n    # 3.监听模式\n    tcp_server.listen(128) # 128同一时间允许接受的最大客户端数\n\n    # 4.循环接受客户端的请求\n    while True:\n        client_socket, addr = tcp_server.accept() # client_socket专门为客户端服务的套接字\n        print(\"专门为你服务的套接字是:\", client_socket)\n        print(\"客户端的地址是:\", addr)\n\n        # 5.处理客户端的请求\n        handle_client(client_socket)\n\n    # 6.关闭套接字\n    tcp_server.close()\n\nif __name__ == '__main__':\n    main()\n```\n\n####总结:\n1.匹配地址正则表达式\nre.match(r\"[^/]+(/[^ ]*)\\s\").group(1)\n\n2.响应报文格式\n响应行\n响应头\n空行\n响应体\n\n### 课堂作业\n1.浏览器输入/,返回首页\n2.浏览器输入/index.html 返回首页\n3.浏览器输入/login.html 返回登陆\n4.浏览器输入register.html 返回注册\n5.浏览器输入其他，返回网页已走失，响应行中状态码为400 NOT FOUND\n\n### 作业讲解\n```\nimport socket\nimport re\n\ndef handle_client(client):\n    # 接受用户的数据\n    data = client.recv(1024).decode(\"utf-8\")\n    print(data)\n    ret = re.match(r\"[^/]+(/[^ ]*)\\s\", data) # '[^/]+(/[^ ]*) '\n    if ret:\n    \tfile_path = ret.group(1)\n    \t# print(1111111111,file_path)\n\t    if file_path == '/':\n\t        file_path = '/index.html'\n    else:\n        client.close()\n        return\n\n    # 响应行\n    response_line = \"HTTP/1.1 200 ok\\r\\n\"\n    # 响应头\n    response_header = \"content-type:text/html;charset=utf-8\\r\\n\"\n    # 空行\n    response_None = \"\\r\\n\"\n\n    if file_path == '/index.html':\n\n        # 响应体\n        response_body = \"欢迎来到王者荣耀\"\n\n    elif file_path == \"/login.html\":\n        # 响应数据\n        # 响应体\n        response_body = \"登录\"\n\n    elif file_path == \"/register.html\":\n        # 响应数据\n        response_body = \"注册\"\n    else:\n        # 响应数据\n        response_line = \"HTTP/1.1 400 NOT FOUND\\r\\n\"\n        response_body = \"网页已经走失\"\n\n\n    response = response_line + response_header + response_None + response_body\n\n    client.send(response.encode('utf-8'))\n    # 关闭客户端套接字\n    client.close()\n\n\ndef main():\n\n\n    # 初始化socket\n    tcp_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    # 端口复用，绑定端口和ip地址\n    tcp_server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)\n    tcp_server.bind((\"\", 8080))\n\n    # 监听模式\n\n    tcp_server.listen(128)\n    # 循环接受用户的请求\n    while True:\n        client_socket, address = tcp_server.accept()\n        # 处理用户的请求\n        handle_client(client_socket)\n\n    # 关闭套接字\n\n    tcp_server.close()\nif __name__ == '__main__':\n    main()\n```\n\n### 返回一个网页\n\n#### 目标\n1.我们已经能够返回固定的数据了，接下来我们返回一个完整的网页\n2.当网页中还有图片时，也是要发送请求的\n\n请求的资源有\n1./post.html\n2./favicon.ico\n3.images/1.png\n4.images/2.png\n5.images/3.png\n\n#### 案例\n浏览器发送请求，服务器返回一个网页\n\n#### 步骤\n1.初始化socket\n2.端口复用，绑定端口和ip地址\n3.监听模式\n4.循环接受用户的请求\n5.处理用户的请求\n\t5.0.接收用户的发送的数据\n\t5.1.使用正则匹配地址\n\t5.2.组装响应报文（不返回文字，返回一个网页）\n\t\t返回的post.html里有图片，图片也需要响应\n\t\t/favicon.ico也需要处理\n\t5.3.发送数据给浏览器\n\t5.4.关闭客户端套接字\n\n6.关闭服务端套接字\n\n#### 代码\n```\n# 初始化套芥子\n# 绑定端口，复用\n# 监听套芥子\n# 循环接受用户的请求\n# 处理用户的请求\nimport threading\nimport socket\nimport re\n\nimport time\n\n\ndef handle_client(client):\n    time.sleep(5)\n    data = client.recv(1024).decode(\"utf-8\")\n\n    ret = re.match(r\"[^/]+(/[^ ]*)\\s\", data)\n    if ret:\n        file_path = ret.group(1)\n        if file_path == \"/\":\n            file_path = \"/post.html\"\n    else:\n        client.close()\n        return\n\n\n    with open(\"static%s\"%file_path, 'rb') as f:\n        data = f.read()\n\n    response_line = \"HTTP/1.1 200 ok\\r\\n\".encode('utf-8')\n    response_header = \"content-type:text/html;charset=utf-8\\r\\n\".encode(\"utf-8\")\n    response_None = \"\\r\\n\".encode(\"utf-8\")\n    response_body = data\n    response = response_line + response_header + response_None +response_body\n    client.send(response)\n\n    client.close()\n    print(11111)\n\ndef main():\n\n\n    # 初始化套芥子\n    tcp_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    # 绑定端口，复用\n    tcp_server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)\n    tcp_server.bind(('', 8080))\n\n    # 监听套芥子\n    tcp_server.listen(128)\n    while True:\n        # 循环接受用户的请求\n\n        client, address = tcp_server.accept()\n        # threading.Thread(target=handle_client, args=(client,)).start()\n        # 处理用户的请求\n\n        handle_client(client)\n\n\n\n\nif __name__ == '__main__':\n    main()\n\n```\n\n#### 总结\n\n1.打开文件内容，返回里面的数据\n2.如果网页中有图片，也是会发送请求，我们需要将图片的数据响应\n\n\n### http服务器面向对象版\n#### 目标\n1.tcp的准备工作代码\n\t1.初始化socket\n\t2.端口复用，绑定端口和ip地址\n\t3.监听模式\n2.核心代码\n\t1.循环接受用户的请求\n\t2.处理用户的请求\n\t3.关闭服务器端socket\n3.处理用户请求的代码\n\t3.1接收用户的发送的数据\n\t3.2响应行\n\t3.3响应头\n\t3.4空行\n\t3.5响应体\n\t3.6发送响应数据\n\t3.7.关闭客户端套\n\n#### 案例\n1.将面向过程改为面向对象版的http服务器\n\n#### 步骤\n1.定义个Tcp_Server类\n2.将tcp服务器的准备工作放到init方法中，全部设置为属性\n3.将核心代码放到run_server方法中\n4.将处理用户请求的代码抽取为一个方法\n\ntcp_server = Tcp_Server()\ntcp_server.run_server()\n\n\n\n```   \nimport socket\nimport re\n\nimport time\n\n\nclass Tcp_Server(object):\n    def __init__(self):\n        # 1.初始化socket\n        self.tcp_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n        # 2.端口复用，绑定端口和ip地址\n        self.tcp_server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)\n        self.tcp_server.bind((\"\", 8080))\n        # 3.监听模式\n        self.tcp_server.listen(128)\n\n    def run_server(self):\n        while True:\n            client, address = self.tcp_server.accept()\n\n            # 5.处理用户的请求\n            self.handle_client(client)\n\n        # 6.关闭客户端套\n        tcp_server.close()\n\n    def handle_client(self, client):\n        time.sleep(4)\n\n        # 5.0.接收用户的发送的数据\n        data = client.recv(1024).decode(\"utf-8\")\n        ret  = re.match(r\"[^/]+(/[^ ]*)\\s\", data)\n        if ret:\n            file_path = ret.group(1)\n            if file_path == \"/\":\n                file_path = \"/post.html\"\n        else:\n            client.close()\n            return\n        print(file_path)\n\n\n        # 响应行\n        response_line = \"HTTP/1.1 200 ok\\r\\n\"\n\n        # 响应头\n        response_header = \"content-type:text/html;charset=utf-8\\r\\n\"\n\n        # 空行\n        response_None = \"\\r\\n\"\n\n        with open('static%s'%file_path, 'rb')as f:\n            content = f.read()\n        response_body = content\n\n        response = response_line.encode('utf-8') + response_header.encode('utf-8') + response_None.encode('utf-8') + response_body\n        client.send(response)\n        client.close()\n\n\n\ndef main():\n\n    tcp_server = Tcp_Server()\n    tcp_server.run_server()\n    # 4.循环接受用户的请求\n\n\nif __name__ == '__main__':\n    main()\n```\n\n####总结\n\n\n\n### http服务器多任务版\n####目标:\n1.多线程\n2.多进程\n3.协程\n如果图片同时出现，说明是多任务\n\n####案例:\n将http服务器面向对象版改为多任务版\n网页中有三种图片，需要同时发送请求\n\n####步骤\n1.多线程\n1.导入模块 threading\n2.处理客户端请求为耗时任务，添加到多线程任务\n3.开启线程\n\n2.多进程\n1.导入模块 multiprocessing\n2.处理客户端请求为耗时任务，添加到多进程任务\n3.开启进程\n注意:在多进程中开启子进程，会把父进程的资源复制一份，所以我们开启多进程，就会有多个client客户端\n需要将client关闭\n\n3.协程\n1.导入模块 gevent\n2.请猴子 打补丁  \nfrom gevent import monkey \nmonkey.patch_all()\n\n3.处理客户端请求为耗时任务，添加到多协程任务\n4.加入到耗时列表\n注意:在协程中我们将任务添加到耗时列表，就是为了阻塞协程，\n但是在当前代码中，是while True，开启的，本身就是一个耗时任务，所以不需要加入耗时列表中\n\n\n#### 总结\n\n####代码\n#####多线程\n```\n# 初始化套芥子\n# 绑定端口，复用\n# 监听套芥子\n# 循环接受用户的请求\n# 处理用户的请求\nimport threading\nimport socket\nimport re\n\nimport time\n\n\ndef handle_client(client):\n    time.sleep(5)\n    data = client.recv(1024).decode(\"utf-8\")\n\n    ret = re.match(r\"[^/]+(/[^ ]*)\\s\", data)\n    if ret:\n        file_path = ret.group(1)\n        if file_path == \"/\":\n            file_path = \"/post.html\"\n    else:\n        client.close()\n        return\n\n\n    with open(\"static%s\"%file_path, 'rb') as f:\n        data = f.read()\n\n    response_line = \"HTTP/1.1 200 ok\\r\\n\".encode('utf-8')\n    response_header = \"content-type:text/html;charset=utf-8\\r\\n\".encode(\"utf-8\")\n    response_None = \"\\r\\n\".encode(\"utf-8\")\n    response_body = data\n    response = response_line + response_header + response_None +response_body\n    client.send(response)\n\n    client.close()\n    print(11111)\n\ndef main():\n\n\n    # 初始化套芥子\n    tcp_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    # 绑定端口，复用\n    tcp_server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)\n    tcp_server.bind(('', 8080))\n\n    # 监听套芥子\n    tcp_server.listen(128)\n    while True:\n        # 循环接受用户的请求\n\n        client, address = tcp_server.accept()\n        threading.Thread(target=handle_client, args=(client,)).start()\n        # 处理用户的请求\n\n        # handle_client(client)\n\n\n\n\nif __name__ == '__main__':\n    main()\n```\n#####多进程\n```\n# 初始化套芥子\n# 绑定端口，复用\n# 监听套芥子\n# 循环接受用户的请求\n# 处理用户的请求\nimport multiprocessing\nimport threading\nimport socket\nimport re\n\nimport time\n\n\ndef handle_client(client):\n    time.sleep(5)\n    data = client.recv(1024).decode(\"utf-8\")\n\n    ret = re.match(r\"[^/]+(/[^ ]*)\\s\", data)\n    if ret:\n        file_path = ret.group(1)\n        if file_path == \"/\":\n            file_path = \"/post.html\"\n    else:\n        client.close()\n        return\n\n\n    with open(\"static%s\"%file_path, 'rb') as f:\n        data = f.read()\n\n    response_line = \"HTTP/1.1 200 ok\\r\\n\".encode('utf-8')\n    response_header = \"content-type:text/html;charset=utf-8\\r\\n\".encode(\"utf-8\")\n    response_None = \"\\r\\n\".encode(\"utf-8\")\n    response_body = data\n    response = response_line + response_header + response_None +response_body\n    client.send(response)\n\n    client.close()\n    print(11111)\n\ndef main():\n\n\n    # 初始化套芥子\n    tcp_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    # 绑定端口，复用\n    tcp_server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)\n    tcp_server.bind(('', 8080))\n\n    # 监听套芥子\n    tcp_server.listen(128)\n    while True:\n        # 循环接受用户的请求\n\n        client, address = tcp_server.accept()\n        multiprocessing.Process(target=handle_client, args=(client,)).start()\n        # threading.Thread(target=handle_client, args=(client,)).start()\n        # 处理用户的请求\n        client.close()\n\n        # handle_client(client)\n\n\n\n\nif __name__ == '__main__':\n    main()\n```\n##### 协程\n```\n# 初始化套芥子\n# 绑定端口，复用\n# 监听套芥子\n# 循环接受用户的请求\n# 处理用户的请求\nimport gevent\nfrom gevent import monkey\nmonkey.patch_all()\nimport multiprocessing\nimport threading\nimport socket\nimport re\n\nimport time\n\nimport gevent\n\n\ndef handle_client(client):\n    time.sleep(5)\n    data = client.recv(1024).decode(\"utf-8\")\n\n    ret = re.match(r\"[^/]+(/[^ ]*)\\s\", data)\n    if ret:\n        file_path = ret.group(1)\n        if file_path == \"/\":\n            file_path = \"/post.html\"\n    else:\n        client.close()\n        return\n\n\n    with open(\"static%s\"%file_path, 'rb') as f:\n        data = f.read()\n\n    response_line = \"HTTP/1.1 200 ok\\r\\n\".encode('utf-8')\n    response_header = \"content-type:text/html;charset=utf-8\\r\\n\".encode(\"utf-8\")\n    response_None = \"\\r\\n\".encode(\"utf-8\")\n    response_body = data\n    response = response_line + response_header + response_None +response_body\n    client.send(response)\n\n    client.close()\n    print(11111)\n\ndef main():\n\n\n    # 初始化套芥子\n    tcp_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    # 绑定端口，复用\n    tcp_server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)\n    tcp_server.bind(('', 8080))\n\n    # 监听套芥子\n    tcp_server.listen(128)\n    while True:\n        # 循环接受用户的请求\n\n        client, address = tcp_server.accept()\n        gevent.spawn(handle_client, client)\n        # multiprocessing.Process(target=handle_client, args=(client,)).start()\n        # threading.Thread(target=handle_client, args=(client,)).start()\n        # 处理用户的请求\n        # client.close()\n\n        # handle_client(client)\n    tcp_server.close()\n\n\n\n\nif __name__ == '__main__':\n    main()\n```\n\n### http服务器在程序外传参\n####目标\n需要掌握sys.argv知识\n\n1.我们的项目是最终放在服务器中的，没有图形化界面的，如果端口重复，会启动错误\n2.在程序外面传递端口号\n3.在终端运行python3 http服务器程序传参.py 8080启动程序\n\n####案例\n在终端运行python3 http服务器程序传参.py 8080  启动程序\n\n####步骤\n1.需要在程序在终端运行传递端口\n2.判断sys.argv的长度是否是2\n3.判断端口参数是否是纯数字\n4.将接收的端口信息转换成int类型，在创建程序时传递给init初始化\n\n####总结\n1.sys.argv可以在程序外传参是一个列表类型\n2.文件名是列表中的第一个元素\n\n\n####代码\n```\nimport multiprocessing\nimport socket\nimport threading\nimport gevent\nimport sys\nfrom gevent import monkey\nmonkey.patch_all()\nimport re\n\nimport time\n\n\ndef handle_client(client):\n    time.sleep(1)\n\n    data = client.recv(1024).decode(\"utf-8\")\n    print(data)\n    # 1.匹配地址\n    ret = re.match(r\"[^/]+(/[^ ]*)\\s\", data)\n    print(ret.group(1))\n    if ret:\n        file_path = ret.group(1)\n        if file_path == \"/\":\n            file_path = \"/post.html\"\n    else:\n        client.close()\n        return\n    print(file_path)\n    response_line = \"HTTP/1.1 200 ok\\r\\n\"\n    response_header = \"content-type:text/html;charset=utf-8\\r\\n\"\n    response_None = \"\\r\\n\"\n\n    if file_path == \"/post.html\":\n        with open(\"post.html\", 'r') as f:\n            content = f.read()\n        response_body = content\n        response = response_line + response_header + response_None + response_body\n        response = response.encode('utf-8')\n        client.send(response)\n    elif file_path == '/favicon.ico':\n        pass\n\n    else:\n        with open('.%s'%file_path, 'rb') as f:\n            content = f.read()\n        response_body = content\n        response = response_line.encode('utf-8') + response_header.encode('utf-8') + response_None.encode('utf-8') + response_body\n\n        client.send(response)\n    client.close()\n    # 组装响应报文\n\n\nclass Tcp_Server(object):\n    def __init__(self, port):\n        self.tcp_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.tcp_server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)\n        self.tcp_server.bind((\"\", port))\n        self.tcp_server.listen(128)\n\n    def run_server(self):\n        while True:\n            client, address = self.tcp_server.accept()\n            # threading.Thread(target=handle_client, args=(client,)).start()\n            # multiprocessing.Process(target=handle_client, args=(client,)).start()\n            gevent.spawn(handle_client, client)\n            # 这里不需要加入到耗时列表中，因为本身就是耗时的\n            # 需要关闭套接字\n            # handle_client(client)\n\n        self.tcp_server.close()\n\ndef main():\n    if len(sys.argv) != 2:\n        print(\"启动程序格式: python3 08.http服务器传参.py 8080\")\n        return\n    \n    if not sys.argv[1].isdigit():\n        print(\"启动程序格式: python3 08.http服务器传参.py 8080\")\n        return\n\n    port = sys.argv[1]\n    # print(type(port))\n    tcp_server = Tcp_Server(int(port))\n    tcp_server.run_server()\n\n\nif __name__ == '__main__':\n    main()\n```"},{"title":"redis集群搭建","url":"/2019/04/09/redis集群搭建/","content":"## redis集群搭建\n\n###### 集群的概念：集群是一组相互独立的、通过高速网络互联的计算机，它们构成了一个组，并以单一系统的模式加以管理。\n\n###### redis数据库准备：\n\n> 创建文件目录conf/7000.conf(有多少个服务器就键几个，ps:可以在不同机器上创建，主要区别是port、bing（真实主机IP）、pidfile、cluster-config-file)\n\n~~~\nport 7000\nbind 172.16.179.130\ndaemonize yes\npidfile 7000.pid\ncluster-enabled yes\ncluster-config-file 7000_node.conf\ncluster-node-timeout 15000\nappendonly yes\n~~~\n\n> 启动：redis-server 7000.conf（有几个就启动几个）\n\n> 查看进程是否启动：ps -ef | grep redis\n\n###### 创建集群\n\n1. redis的安装包中包含了redis-trib.rb，⽤于创建集群\n\n2. 接下来的操作在172.16.179.130（可以在集群内的任一机器上执行）机器上进⾏\n\n3. 将命令复制，这样可以在任何⽬录下调⽤此命令\n\n   ~~~\n   sudo cp /usr/share/doc/redis-tools/examples/redis-trib.rb /usr/local/bin/\n   ~~~\n\n4. 安装ruby环境，因为redis-trib.rb是⽤ruby开发的\n\n   ~~~\n   sudo apt-get install ruby\n   ~~~\n\n5. 运⾏如下命令创建集群（包含所有创建集群的redis程序）ps：集群会从参与集群的redis程序中选取不少于一半的程序作为主服务器（少于的话整个集群无法提供服务）\n\n   ~~~\n   redis-trib.rb create --replicas 1 172.16.179.130:7000 172.16.179.130:7001 172.16.179.130:7002 172.16.179.131:7003 172.16.179.131:7004 172.16.179.131:7005集群是\n   ~~~\n\n###### 数据怎么决定存在哪个redis上（CRC16）\n\n理解关键点：\n\n+ 去中心化、去中间件 负载均衡\n+ 哈希槽（hash slot）分配、默认16384个槽（solt）、具体算法CRC16(key) % 16384 如果有n个redis master，每个redis master均分16384个槽，而且是连续的\n+ Redis 集群会把数据存在⼀个 master 节点，然后在这个 master 和其对应的salve 之间进⾏数据同步。当读取数据时，也根据⼀致性哈希算法到对应的 master 节 点获取数据。只有当⼀个master 挂掉之后，才会启动⼀个对应的 salve 节点，充 当 master\n+ 需要注意的是：必须要3个或以上的主节点，否则在创建集群时会失败，并且当存 活的主节点数⼩于总节点数的⼀半时，整个集群就⽆法提供服务了\n\n###### redis cluster与python交互\n\n1. 安装依赖包\n\n   ~~~\n   pip install redis-py-cluster\n   ~~~\n\n2. 连接示例\n\n   ~~~python\n   from rediscluster import *\n   if __name__ == '__main__':\n   \ttry:\n       # 构建所有的节点，Redis会使⽤CRC16算法，将键和值写到某个节点上(连接的是集群里面的master节点)\n       startup_nodes = [\n           {'host': '192.168.26.128', 'port': '7000'},\n           {'host': '192.168.26.130', 'port': '7003'},\n           {'host': '192.168.26.128', 'port': '7001'},\n       ]\n       # 构建StrictRedisCluster对象                   \t  \tsrc=StrictRedisCluster(startup_nodes=startup_nodes,decode_responses=True)\n       # 设置键为name、值为itheima的数据\n       result=src.set('name','itheima')\n       print(result)\n       # 获取键为name\n       name = src.get('name')\n       print(name)\n     except Exception as e:\n       print(e)\n   ~~~\n\n   \n\n"},{"title":"mysql的主从同步&&读写分离 （Django）","url":"/2018/11/30/mysql主从&读写分离/","content":"\n# mysql的主从同步&&读写分离 （Django）                                                                                                                                                           \n\n## 主从同步\n\n**定义：**主从同步使得数据可以从一个数据库服务器复制到其他服务器上，在复制数据时，一个服务器充当主服务器（master），其余的服务器充当从服务器（slave）---异步复制、不需要一直连、通过配置文件指定复制内容\n\n**好处：**\n\n+ 提高数据库性能\n+ 提高数据安全\n+ 提高主服务器性能\n\n**同步机制：**\n\n+ 二进制日志\n+ 在使用二进制日志时，主服务器的所有操作都会被记录下来，然后从服务器会接收到该日志的一个副本。从服务器可以指定执行该日志中的哪一类事件（譬如只插入数据或者只更新数据），默认会执行日志中的所有语句。\n+ 每一个从服务器会记录关于二进制日志的信息：文件名和已经处理过的语句，这样意味着不同的从服务器可以分别执行同一个二进制日志的不同部分，并且从服务器可以随时连接或者中断和服务器的连接。\n+ 主服务器和每一个从服务器都必须配置一个唯一的ID号（在my.cnf文件的[mysqld]模块下有一个server-id配置项），另外，每一个从服务器还需要通过CHANGE MASTER TO语句来配置它要连接的主服务器的ip地址，日志文件名称和该日志里面的位置（这些信息存储在主服务器的数据库里）\n\n**基本步骤：**\n\n1. 在主服务器上，必须开启二进制日志机制和配置一个独立的ID\n2. 在每一个从服务器上，配置一个唯一的ID，创建一个用来专门复制主服务器数据的账号\n3. 在开始复制进程前，在主服务器上记录二进制文件的位置信息\n4. 如果在开始复制之前，数据库中已经有数据，就必须先创建一个数据快照（可以使用mysqldump导出数据库，或者直接复制数据文件）\n5. 配置从服务器要连接的主服务器的IP地址和登陆授权，二进制日志文件名和位置\n\n**要点说明（用docker运行从服务器）：**\n\n+ 主从数据库版本尽量相同或版本接近\n\n+ 创建文件夹mysql_slave文件夹，并将mysql配置文件夹mysql.conf.d拷贝到此处，按如下修改\n\n  ~~~\n  port  =  8306\n  general_log  = 0\n  server-id  = 2\n  ~~~\n\n+ 创建docker容器\n\n  ~~~\n  docker run --name mysql-slave -e MYSQL_ROOT_PASSWORD=mysql -d --network=host -v /home/python/mysql_slave/data:/var/lib/mysql -v /home/python/mysql_slave/mysql.conf.d:/etc/mysql/mysql.conf.d  mysql:5.7.22\n  ~~~\n\n+ 测试，在ubuntu中使用mysql命令尝试连接docker容器中的mysql\n\n  ~~~\n  mysql -uroot -pmysql -h 127.0.0.1 --port=8306\n  ~~~\n\n+ 主服务器数据备份（--all-databases ：导出所有数据库、--lock-all-tables ：执行操作时锁住所有表，防止操作时有数据修改）\n\n  ~~~\n  mysqldump -uroot -pmysql --all-databases --lock-all-tables > ~/master_db.sql\n  ~~~\n\n+ 在docker容器中导入数据\n\n  ~~~\n  mysql -uroot -pmysql -h127.0.0.1 --port=8306 < ~/master_db.sql\n  ~~~\n\n+ #### 配置主服务器master（设置log_bin和server-id）\n\n  ~~~\n  sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf\n  ~~~\n\n  ~~~\n  server-id    =1\n  log_bin      =/var/log/mysql/mysql-bin.log\n  ~~~\n\n+ 重启mysql服务\n\n  ~~~\n  sudo service mysql restart\n  ~~~\n\n+ 登入主服务器Ubuntu中的mysql，创建用于从服务器同步数据使用的帐号\n\n  ~~~\n  mysql –uroot –pmysql\n  \n  GRANT REPLICATION SLAVE ON *.* TO 'slave'@'%' identified by 'slave';\n  \n  FLUSH PRIVILEGES;\n  \n  ~~~\n\n+ 获取主服务器的二进制日志信息(File为使用的日志文件名字，Position为使用的文件位置，这两个参数须记下，配置从服务器时会用到)\n\n  ~~~\n  SHOW MASTER STATUS;\n  ~~~\n\n+ #### 配置从服务器slave （docker中的mysql）\n\n  1. 进入docker\n\n     ~~~\n     docker exec -it cd1513c6afce /bin/bash\n     ~~~\n\n  2. 进入docker中的mysql\n\n     ~~~\n     mysql -uroot -pmysql -h 127.0.0.1 --port=8306\n     ~~~\n\n  3. 执行（master_host:主服务器Ubuntu的ip地址、master_log_file: 前面查询到的主服务器日志文件名、master_log_pos: 前面查询到的主服务器日志文件位置）\n\n     ~~~\n     change master to master_host='127.0.0.1', master_user='slave', master_password='slave',master_log_file='mysql-bin.000006', master_log_pos=590;\n     ~~~\n\n  4. 启动slave服务器，并查看同步状态(Slave_IO_Running:Yes、Slave_SQL_Running:Yes)\n\n     ~~~\n     start slave;\n     show slave status \\G\n     ~~~\n\n     \n\n## 配置Django实现读写分离\n\n1. ####  在配置文件中增加slave数据库的配置\n\n   ~~~python\n   DATABASES = {\n       'default': {\n           'ENGINE': 'django.db.backends.mysql',\n           'HOST': '127.0.0.1',  # 数据库主机\n           'PORT': 3306,  # 数据库端口\n           'USER': 'root',  # 数据库用户名\n           'PASSWORD': 'mysql',  # 数据库用户密码\n           'NAME': 'meiduo'  # 数据库名字\n       },\n       'slave': {\n           'ENGINE': 'django.db.backends.mysql',\n           'HOST': '127.0.0.1',  # 数据库主机\n           'PORT': 8306,  # 数据库端口\n           'USER': 'root',  # 数据库用户名\n           'PASSWORD': 'mysql',  # 数据库用户密码\n           'NAME': 'meiduo'  # 数据库名字\n       }\n   }\n   ~~~\n\n2. ### **创建数据库操作的路由分发类**\n\n   ~~~python\n   class MasterSlaveRouter(object):\n       \"\"\"数据库主从读写分离路由\"\"\"\n   \n       def db_for_read(self, model, **hints):\n           \"\"\"读数据库\"\"\"\n           return \"slave\"\n   \n       def db_for_write(self, model, **hints):\n           \"\"\"写数据库\"\"\"\n           return \"default\"\n   \n       def allow_relation(self, obj1, obj2, **hints):\n           \"\"\"是否运行关联操作\"\"\"\n           return True\n   ~~~\n\n3. #### 配置读写分离路由\n\n   ~~~python\n   # 配置读写分离\n   DATABASE_ROUTERS = ['utils.db_router.MasterSlaveRouter']\n   ~~~\n\n   "}]