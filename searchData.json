[{"title":"python&&django连接redis sentinel集群（哨兵模式）","url":"/2019/12/31/python连接redis sentinel集群（哨兵模式）/","content":"## python 连接redis sentinel\n\n> 相关依赖包\n\n~~~python\nimport redis\nfrom redis.sentinel import Sentinel\n~~~\n\n> 连接哨兵服务器(主机名也可以用域名)\n\n~~~python\nsentinel = Sentinel([('172.31.0.2', 5001),\n('172.31.0.3', 5001),\n('172.31.0.4', 5001),\n('172.31.0.5', 5001)\n],\nsocket_timeout=0.5)\n~~~\n\n> 获取主服务器地址\n\n~~~python\nmaster = sentinel.discover_master('mymaster')\nprint(master)\n# 输出：('172.31.0.2', 5001)\n~~~\n\n> 获取从服务器地址\n\n~~~python\nslave = sentinel.discover_slaves('mymaster')\nprint(slave)\n# 输出：[('172.31.3', 5001), ('172.31.0.4', 5001), ('172.31.0.5', 5001)]\n~~~\n\n> 获取主服务器进行写入\n\n~~~python\nmaster = sentinel.master_for('mymaster', socket_timeout=0.5, password='redis_auth_pass', db=15)\nw_ret = master.set('foo', 'bar')\n# 输出：True\n~~~\n\n> 获取从服务器进行读取（默认是round-roubin）\n\n~~~python\nslave = sentinel.slave_for('mymaster', socket_timeout=0.5, password='redis_auth_pass', db=15)\nr_ret = slave.get('foo')\nprint(r_ret)\n# 输出：bar\n~~~\n\n## django连接redis sentinel\n\n### 方法一\n\n> 依赖包\n\n~~~\npip install django-redis-sentinel\n~~~\n\n> 配置信息\n\n~~~python\nCACHES = {\n        \"default\": {\n            \"BACKEND\": \"django_redis.cache.RedisCache\",\n            \"LOCATION\": \"redis_master/sentinel-host1:2639,sentinel-host2:2639/0\"\n            \"OPTIONS\": {\n                \"PASSWORD\": 's3cret_passw0rd!',\n                \"CLIENT_CLASS\": \"django_redis_sentinel.SentinelClient\",\n            }\n        }\n    }\n~~~\n\n> 配置例子\n\n~~~python\nCACHES = {\n    \"default\": {\n        \"BACKEND\": \"django_redis.cache.RedisCache\",\n        \"LOCATION\": [\n            \"redis://127.0.0.1:6379?db=1\",\n            \"redis://127.0.0.1:6379?db=1\",\n        ],\n        \"OPTIONS\": {\n            \"CLIENT_CLASS\": \"django_redis_sentinel.SentinelClient\",\n        }\n    },\n}\n~~~\n\n### 方法二（HA（high、available）：高可用版）\n\n> 依赖包(依赖方法一的包)\n\n~~~\npip install django-redis-sentinel\n~~~\n\n> 配置\n\n~~~python\nCACHES = {\n    \"default\": {\n        \"BACKEND\": \"django_redis_sentinel.cache.RedisSentinelCache\",\n        \"LOCATION\": [\n            (\"sentinel1\", 26379),  # 必须元组\n            (\"sentinel2\", 26379),\n            (\"sentinel3\", 26379)\n        ],\n        \"OPTIONS\": {\n            \"CLIENT_CLASS\": \"django_redis_sentinel.client.SentinelClient\",\n            \"SENTINEL_SERVICE_NAME\": \"rmaster\",\n            \"REDIS_CLIENT_KWARGS\": {\n                \"db\": 1\n            }\n        }\n    }\n}\n~~~\n\n"},{"title":"Note","url":"/2019/04/13/课堂笔记/","content":"\n\nhttp服务器\n\n## http协议简单介绍以及这部分内容学完我们能做什么？\n打开谷歌浏览器，输入www.taobao.com 网址就变成了https://www.taobao.com\nhttp协议：超文本传输协议，通俗理解，就是规定浏览器和服务器之间传输数据的的协议\n\n制作者：蒂姆·伯纳斯-李\n发展史：http/1.0版本  都是用的短连接\nhttp/1.1版本  使用的就是长连接\n\n## 浏览器访问的过程\n\n见图\n\n## 浏览器和服务器通信方式TCP\n## 目标:\n1.浏览器是客户端\n2.服务器是服务器端\n\n验证：\n把浏览器作为客户端，使用网络调试助手模拟TCP服务器端 \n把tcp服务器端的地址设定为127.0.0.1 端口为8080，我们http协议默认的端口就是80\n总结：\n1.浏览器底层就是tcp客户端\n2.web服务器端底层就是tcp服务器端\n\n工作经验:我们如果去写浏览器，但是浏览器都是一些大公司做的，你写的谁用，小公司，客户人数太少\n\n## 域名的介绍\n\n我们之前说了浏览器底层就是tcp客户端，那么客户端访问服务器端是不是需要端口和ip\n\n我们输入www.taobao.com它不是个ip地址，它成为域名\n\nping www.baidu.com  我们就可以看到百度的ip地址了\n早起美国网络起源时，会将一个域名对应一个ip地址。类似于我们的电话簿\n\ndns服务器，就负责解析域名对应的ip地址\n\n\nwww.baidu.com  --> ip http://14.215.177.39/\n扩展:我们将来买一个服务器给你一个ip地址，你也可以去买一个域名，和ip进行一个绑定\n\n总结:\n域名的作用:能够将ip地址进行解析，方便用户能够记忆\n\n## 请求与响应\n\n我们要根据不同的地址返回不同的页面，就要清楚的知道请求的时候携带的一些信息\n\n详解请求的数据\n\n## 请求的地址\n输入127.0.0.1:8080\n查看网络调试助手中的信息\n请求行格式: 请求的方式 空格 请求的地址 空格 http协议的版本\nGET / HTTP/1.1\n如果请求时不输入具体的网页地址，默认是/\n\n输入127.0.0.1:8080/index.html\nGET /index.html HTTP/1.1\n\n## 请求的2种方式\n\n1.get请求方式\n```\nGET /index.html HTTP/1.1 \nHost: 127.0.0.1:8080\nConnection: keep-alive\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36\nAccept-Encoding: gzip, deflate, sdch\nAccept-Language: zh-CN,zh;q=0.8\n\n\n```\nget方式的请求格式\n1.请求行\n2.请求头\n\n2.post请求方式\n```\nPOST / HTTP/1.1\nHost: 127.0.0.1:8080\nConnection: keep-alive\nContent-Length: 24\nCache-Control: max-age=0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\nOrigin: null\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36\nContent-Type: application/x-www-form-urlencoded\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.8\n\nname=zhangsan&pwd=123456\n```\npost请求方式的格式\n1.请求行\n2.请求头\n3.空行\n4.请求体\n\n总结：\n\n请求数据的结构：\n1.请求行\n\t1.1请求方式;\n\t\t1.get  一般输入地址，就是get方式\n\n\t\t2.post  (简单了解) 我们提交一些数据时比如注册，登录这种请求就是post请求方式\n\t1.2 请求的具体地址\n\t\t如果只请求 127.0.0.1  这个就是/ 根目录\n\t\t如果请求的是 127.0.0.1/index.html     /index.html 就是具体的请求地址\n\t\n\t1.3 http版本号 我们现在都是用的http1.1协议\n\n2.其余的是请求头\n3.空行\n4.请求体（get请求方式没有请求体，只有post请求方式有请求体，需要提交数据）\n\n总结: 请求行     请求方式 空格隔开 请求的具体地址 空格隔开 http协议版本\n\n## 请求头详解\n```\nPOST / HTTP/1.1 请求行\nHost: 127.0.0.1:8080  主机地址 ip端口\nConnection: keep-alive 长链接 http1.1版本都是长链接\nContent-Length: 24 接收的数据长度  我们现在都是长链接，怎么判断客户端是否断开了呢，就可以根据长度判断，客户端说明发送的数据长度，我接收到了这个长度的数据，就说明客户端发送一次数据结束\nCache-Control: max-age=0 缓存数据保存时间  生命周期\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 接收的数据类型\nOrigin: null  \nUpgrade-Insecure-Requests: 1  这个两个都是和我们cache缓存相关的\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36 浏览器版本信息头 这是一个反爬的手段，判断这个头，知道是否是浏览器请求的数据，还是爬虫去爬取我的数据  \nContent-Type: application/x-www-form-urlencoded  发送的数据格式 html  text 文本\nAccept-Encoding: gzip, deflate 允许接收压缩格式的文件，为了浏览器快速去解析内容\nAccept-Language: zh-CN,zh;q=0.8 浏览器能够理解的语言 中文\n\nname=zhangsan&pwd=123456\n```\n\n重点掌握 User-Agent 浏览器版本信息头\n\n## 请求总结：\n完善图\n\n## tcp服务器端接收浏览器请求的数据\n\n## 响应的格式\n\n1.体验响应效果\n\n```\nHTTP/1.1 200 ok     HTTP/1.1 404 not found\ncontent-length:4\n\nhello world\n```\n2.响应数据详解：\n1.响应行  HTTP/1.1 200 ok\n2.响应头 content-length:4\n3.空行 \n4.响应内容 hello world\n\n3.使用开发者工具查看响应数据信息 \n\n\n## 响应行中的状态码的介绍\n状态码的作用:浏览器向服务器发送了请求，那么服务器就要响应数据给它，状态码就代表响应的状态\n一般是给我们程序员看到\n1.200 ok  成功返回响应的数据\n2.303 重定向 跳转链接\n3.404 not found  一般是请求地址错误\n4.500 一般是服务器出现了故障\n\n总结：重点掌握 200 404\n\n## 响应头的介绍\n1.content-length  响应数据的长度\n2.content-type: text/html; charset=utf-8\n```\nHTTP/1.1 200 ok\n\nhello world\n```\n这样浏览器不会接受到数据，必须关闭服务器才能接受到，我们正常服务器是不会主动关闭的，所以需要说明我们发送的数据的长度\n```\nHTTP/1.1 200 ok\ncontent-length:100\n\nhello world\n```\n\n\n\n\n```\nHTTP/1.1 200 ok\ncontent-length:100\n\n我是中国人\n```\n这样的响应数据，浏览器会乱码，我们发送响应体是中文，所有要设置浏览器能够知道的编码\n```\nHTTP/1.1 200 ok\ncontent-type:text/html;charset=utf-8\ncontent-length:100\n\n我是中国人\n```\n\n## 响应总结\n完善图\n\n## tcp服务器接收发送数据给浏览器\n## 完整的浏览器访问服务器的过程\n总结\n\n## 调式工具\nF12 开发者工具\n\n## http课件内容回顾\n1.http是基于tcp的基础之上的  \n在传输层  网络通信 有两个方式 udp、tcp\n\n2.报文的理解，报纸 文章\n\n## 长连接和短连接\n\n目标：\n1.知道http1.0是使用的短连接\n2.知道http1.1是使用长连接\n3.知道长连接和短连接的区别\n\n案例:\n1. 短连接好比是单程票 一次请求和响应就断开浏览器客户端\n2.长连接好比是一卡通，可以实现多次来回的请求和响应，直到客户端没有数据发送，断开连接\n\n总结:\n1.短连接的特点：减少资源的占用，但是减慢了访问的速度\n2.长连接的特点：提高访问的速度，增加服务器端的资源的开销\n\n###http服务器（返回固定的数据）\n####目标:\n1.http服务器就是tcp服务器\n2.http服务器响应数据的格式\n\t1. 响应行\n\t2. 响应头\n\t3. 空行\n\t4. 响应体\n3.换行回车  \\r\\n \n\n####案例:写一个返回固定数据的http服务器\n\n####步骤:\n1.初始化socket\n2.端口复用，绑定端口和ip地址\n3.监听模式\n4.循环接受用户的请求\n5.处理用户的请求\n\t5.0.接收用户的发送的数据\n\t5.1响应行\n\t5.2响应头\n\t5.3空行\n\t5.4响应体\n\t5.5发送响应数据\n\t5.6.关闭客户端套\n6.关闭套接字\n\n####总结:\n1.http服务器基于tcp\n2.响应数据，换行回车  \\r\\n \n\n响应数据的格式:\n1. 响应行\n2. 响应头\n3. 空行\n4. 响应体\n\n### 获取http请求数据中的地址(正则)\n####目标\n1.请求报文的格式:\n请求行\n请求头\n空行\n请求体\n\n2.服务器接收浏览器发送的数据，解析里的地址\n3. 请求行的格式\nGET 空格 地址 空格 http版本\nGET / http/1.1\n\n####案例\n浏览器向服务器发送数据，解析请求数据中的地址,如果地址正确发送响应报文\n\n####步骤\n1.初始化socket\n2.端口复用，绑定端口和ip地址\n3.监听模式\n4.循环接受用户的请求\n5.处理用户的请求\n\t5.0.接收用户的发送的数据\n\t5.1.使用正则匹配地址\n\t5.2.组装响应报文\n\t5.3.发送数据给浏览器\n\t5.4.关闭客户端套接字\n\n6.关闭客户端套\n\n\n```\nimport socket\nimport re\n\n\ndef handle_client(client):\n    \"处理用户的请求\"\n    data = client.recv(1024).decode('utf-8')\n    print(data) # GET /index.html HTTP/1.1\n\n    # ret = re.match(\"[^/]+(/.*?)\\s\", data)\n    ret = re.match(\"[^/]+(/[^ ]*)\\s\", data)\n\n    if ret:\n        path = ret.group(1)\n        \n    else:\n        client.close()\n        return\n\n    if path == \"/index.html\":\n        response_line = \"HTTP/1.1 200 ok\\r\\n\"\n        response_header = \"content-type:text/html;charset=utf-8\\r\\n\"\n        response_none = \"\\r\\n\"\n        response_body = \"欢迎来到王者荣耀\"\n        response = response_line + response_header + response_none + response_body\n\n        client.send(response.encode('utf-8'))\n\n        client.close()\n\ndef main():\n    \"主函数\"\n    # 1.创建套接字\n    tcp_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    # 端口释放需要时间，0-4分钟之间，设置端口可以复用\n    tcp_server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)\n    # 2.绑定地址\n    tcp_server.bind((\"\", 8080)) # 绑定的地址是一个元组，第一个是ip,字符串类型，第二个是port，数字类型\n\n    # 3.监听模式\n    tcp_server.listen(128) # 128同一时间允许接受的最大客户端数\n\n    # 4.循环接受客户端的请求\n    while True:\n        client_socket, addr = tcp_server.accept() # client_socket专门为客户端服务的套接字\n        print(\"专门为你服务的套接字是:\", client_socket)\n        print(\"客户端的地址是:\", addr)\n\n        # 5.处理客户端的请求\n        handle_client(client_socket)\n\n    # 6.关闭套接字\n    tcp_server.close()\n\nif __name__ == '__main__':\n    main()\n```\n\n####总结:\n1.匹配地址正则表达式\nre.match(r\"[^/]+(/[^ ]*)\\s\").group(1)\n\n2.响应报文格式\n响应行\n响应头\n空行\n响应体\n\n### 课堂作业\n1.浏览器输入/,返回首页\n2.浏览器输入/index.html 返回首页\n3.浏览器输入/login.html 返回登陆\n4.浏览器输入register.html 返回注册\n5.浏览器输入其他，返回网页已走失，响应行中状态码为400 NOT FOUND\n\n### 作业讲解\n```\nimport socket\nimport re\n\ndef handle_client(client):\n    # 接受用户的数据\n    data = client.recv(1024).decode(\"utf-8\")\n    print(data)\n    ret = re.match(r\"[^/]+(/[^ ]*)\\s\", data) # '[^/]+(/[^ ]*) '\n    if ret:\n    \tfile_path = ret.group(1)\n    \t# print(1111111111,file_path)\n\t    if file_path == '/':\n\t        file_path = '/index.html'\n    else:\n        client.close()\n        return\n\n    # 响应行\n    response_line = \"HTTP/1.1 200 ok\\r\\n\"\n    # 响应头\n    response_header = \"content-type:text/html;charset=utf-8\\r\\n\"\n    # 空行\n    response_None = \"\\r\\n\"\n\n    if file_path == '/index.html':\n\n        # 响应体\n        response_body = \"欢迎来到王者荣耀\"\n\n    elif file_path == \"/login.html\":\n        # 响应数据\n        # 响应体\n        response_body = \"登录\"\n\n    elif file_path == \"/register.html\":\n        # 响应数据\n        response_body = \"注册\"\n    else:\n        # 响应数据\n        response_line = \"HTTP/1.1 400 NOT FOUND\\r\\n\"\n        response_body = \"网页已经走失\"\n\n\n    response = response_line + response_header + response_None + response_body\n\n    client.send(response.encode('utf-8'))\n    # 关闭客户端套接字\n    client.close()\n\n\ndef main():\n\n\n    # 初始化socket\n    tcp_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    # 端口复用，绑定端口和ip地址\n    tcp_server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)\n    tcp_server.bind((\"\", 8080))\n\n    # 监听模式\n\n    tcp_server.listen(128)\n    # 循环接受用户的请求\n    while True:\n        client_socket, address = tcp_server.accept()\n        # 处理用户的请求\n        handle_client(client_socket)\n\n    # 关闭套接字\n\n    tcp_server.close()\nif __name__ == '__main__':\n    main()\n```\n\n### 返回一个网页\n\n#### 目标\n1.我们已经能够返回固定的数据了，接下来我们返回一个完整的网页\n2.当网页中还有图片时，也是要发送请求的\n\n请求的资源有\n1./post.html\n2./favicon.ico\n3.images/1.png\n4.images/2.png\n5.images/3.png\n\n#### 案例\n浏览器发送请求，服务器返回一个网页\n\n#### 步骤\n1.初始化socket\n2.端口复用，绑定端口和ip地址\n3.监听模式\n4.循环接受用户的请求\n5.处理用户的请求\n\t5.0.接收用户的发送的数据\n\t5.1.使用正则匹配地址\n\t5.2.组装响应报文（不返回文字，返回一个网页）\n\t\t返回的post.html里有图片，图片也需要响应\n\t\t/favicon.ico也需要处理\n\t5.3.发送数据给浏览器\n\t5.4.关闭客户端套接字\n\n6.关闭服务端套接字\n\n#### 代码\n```\n# 初始化套芥子\n# 绑定端口，复用\n# 监听套芥子\n# 循环接受用户的请求\n# 处理用户的请求\nimport threading\nimport socket\nimport re\n\nimport time\n\n\ndef handle_client(client):\n    time.sleep(5)\n    data = client.recv(1024).decode(\"utf-8\")\n\n    ret = re.match(r\"[^/]+(/[^ ]*)\\s\", data)\n    if ret:\n        file_path = ret.group(1)\n        if file_path == \"/\":\n            file_path = \"/post.html\"\n    else:\n        client.close()\n        return\n\n\n    with open(\"static%s\"%file_path, 'rb') as f:\n        data = f.read()\n\n    response_line = \"HTTP/1.1 200 ok\\r\\n\".encode('utf-8')\n    response_header = \"content-type:text/html;charset=utf-8\\r\\n\".encode(\"utf-8\")\n    response_None = \"\\r\\n\".encode(\"utf-8\")\n    response_body = data\n    response = response_line + response_header + response_None +response_body\n    client.send(response)\n\n    client.close()\n    print(11111)\n\ndef main():\n\n\n    # 初始化套芥子\n    tcp_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    # 绑定端口，复用\n    tcp_server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)\n    tcp_server.bind(('', 8080))\n\n    # 监听套芥子\n    tcp_server.listen(128)\n    while True:\n        # 循环接受用户的请求\n\n        client, address = tcp_server.accept()\n        # threading.Thread(target=handle_client, args=(client,)).start()\n        # 处理用户的请求\n\n        handle_client(client)\n\n\n\n\nif __name__ == '__main__':\n    main()\n\n```\n\n#### 总结\n\n1.打开文件内容，返回里面的数据\n2.如果网页中有图片，也是会发送请求，我们需要将图片的数据响应\n\n\n### http服务器面向对象版\n#### 目标\n1.tcp的准备工作代码\n\t1.初始化socket\n\t2.端口复用，绑定端口和ip地址\n\t3.监听模式\n2.核心代码\n\t1.循环接受用户的请求\n\t2.处理用户的请求\n\t3.关闭服务器端socket\n3.处理用户请求的代码\n\t3.1接收用户的发送的数据\n\t3.2响应行\n\t3.3响应头\n\t3.4空行\n\t3.5响应体\n\t3.6发送响应数据\n\t3.7.关闭客户端套\n\n#### 案例\n1.将面向过程改为面向对象版的http服务器\n\n#### 步骤\n1.定义个Tcp_Server类\n2.将tcp服务器的准备工作放到init方法中，全部设置为属性\n3.将核心代码放到run_server方法中\n4.将处理用户请求的代码抽取为一个方法\n\ntcp_server = Tcp_Server()\ntcp_server.run_server()\n\n\n\n```   \nimport socket\nimport re\n\nimport time\n\n\nclass Tcp_Server(object):\n    def __init__(self):\n        # 1.初始化socket\n        self.tcp_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n        # 2.端口复用，绑定端口和ip地址\n        self.tcp_server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)\n        self.tcp_server.bind((\"\", 8080))\n        # 3.监听模式\n        self.tcp_server.listen(128)\n\n    def run_server(self):\n        while True:\n            client, address = self.tcp_server.accept()\n\n            # 5.处理用户的请求\n            self.handle_client(client)\n\n        # 6.关闭客户端套\n        tcp_server.close()\n\n    def handle_client(self, client):\n        time.sleep(4)\n\n        # 5.0.接收用户的发送的数据\n        data = client.recv(1024).decode(\"utf-8\")\n        ret  = re.match(r\"[^/]+(/[^ ]*)\\s\", data)\n        if ret:\n            file_path = ret.group(1)\n            if file_path == \"/\":\n                file_path = \"/post.html\"\n        else:\n            client.close()\n            return\n        print(file_path)\n\n\n        # 响应行\n        response_line = \"HTTP/1.1 200 ok\\r\\n\"\n\n        # 响应头\n        response_header = \"content-type:text/html;charset=utf-8\\r\\n\"\n\n        # 空行\n        response_None = \"\\r\\n\"\n\n        with open('static%s'%file_path, 'rb')as f:\n            content = f.read()\n        response_body = content\n\n        response = response_line.encode('utf-8') + response_header.encode('utf-8') + response_None.encode('utf-8') + response_body\n        client.send(response)\n        client.close()\n\n\n\ndef main():\n\n    tcp_server = Tcp_Server()\n    tcp_server.run_server()\n    # 4.循环接受用户的请求\n\n\nif __name__ == '__main__':\n    main()\n```\n\n####总结\n\n\n\n### http服务器多任务版\n####目标:\n1.多线程\n2.多进程\n3.协程\n如果图片同时出现，说明是多任务\n\n####案例:\n将http服务器面向对象版改为多任务版\n网页中有三种图片，需要同时发送请求\n\n####步骤\n1.多线程\n1.导入模块 threading\n2.处理客户端请求为耗时任务，添加到多线程任务\n3.开启线程\n\n2.多进程\n1.导入模块 multiprocessing\n2.处理客户端请求为耗时任务，添加到多进程任务\n3.开启进程\n注意:在多进程中开启子进程，会把父进程的资源复制一份，所以我们开启多进程，就会有多个client客户端\n需要将client关闭\n\n3.协程\n1.导入模块 gevent\n2.请猴子 打补丁  \nfrom gevent import monkey \nmonkey.patch_all()\n\n3.处理客户端请求为耗时任务，添加到多协程任务\n4.加入到耗时列表\n注意:在协程中我们将任务添加到耗时列表，就是为了阻塞协程，\n但是在当前代码中，是while True，开启的，本身就是一个耗时任务，所以不需要加入耗时列表中\n\n\n#### 总结\n\n####代码\n#####多线程\n```\n# 初始化套芥子\n# 绑定端口，复用\n# 监听套芥子\n# 循环接受用户的请求\n# 处理用户的请求\nimport threading\nimport socket\nimport re\n\nimport time\n\n\ndef handle_client(client):\n    time.sleep(5)\n    data = client.recv(1024).decode(\"utf-8\")\n\n    ret = re.match(r\"[^/]+(/[^ ]*)\\s\", data)\n    if ret:\n        file_path = ret.group(1)\n        if file_path == \"/\":\n            file_path = \"/post.html\"\n    else:\n        client.close()\n        return\n\n\n    with open(\"static%s\"%file_path, 'rb') as f:\n        data = f.read()\n\n    response_line = \"HTTP/1.1 200 ok\\r\\n\".encode('utf-8')\n    response_header = \"content-type:text/html;charset=utf-8\\r\\n\".encode(\"utf-8\")\n    response_None = \"\\r\\n\".encode(\"utf-8\")\n    response_body = data\n    response = response_line + response_header + response_None +response_body\n    client.send(response)\n\n    client.close()\n    print(11111)\n\ndef main():\n\n\n    # 初始化套芥子\n    tcp_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    # 绑定端口，复用\n    tcp_server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)\n    tcp_server.bind(('', 8080))\n\n    # 监听套芥子\n    tcp_server.listen(128)\n    while True:\n        # 循环接受用户的请求\n\n        client, address = tcp_server.accept()\n        threading.Thread(target=handle_client, args=(client,)).start()\n        # 处理用户的请求\n\n        # handle_client(client)\n\n\n\n\nif __name__ == '__main__':\n    main()\n```\n#####多进程\n```\n# 初始化套芥子\n# 绑定端口，复用\n# 监听套芥子\n# 循环接受用户的请求\n# 处理用户的请求\nimport multiprocessing\nimport threading\nimport socket\nimport re\n\nimport time\n\n\ndef handle_client(client):\n    time.sleep(5)\n    data = client.recv(1024).decode(\"utf-8\")\n\n    ret = re.match(r\"[^/]+(/[^ ]*)\\s\", data)\n    if ret:\n        file_path = ret.group(1)\n        if file_path == \"/\":\n            file_path = \"/post.html\"\n    else:\n        client.close()\n        return\n\n\n    with open(\"static%s\"%file_path, 'rb') as f:\n        data = f.read()\n\n    response_line = \"HTTP/1.1 200 ok\\r\\n\".encode('utf-8')\n    response_header = \"content-type:text/html;charset=utf-8\\r\\n\".encode(\"utf-8\")\n    response_None = \"\\r\\n\".encode(\"utf-8\")\n    response_body = data\n    response = response_line + response_header + response_None +response_body\n    client.send(response)\n\n    client.close()\n    print(11111)\n\ndef main():\n\n\n    # 初始化套芥子\n    tcp_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    # 绑定端口，复用\n    tcp_server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)\n    tcp_server.bind(('', 8080))\n\n    # 监听套芥子\n    tcp_server.listen(128)\n    while True:\n        # 循环接受用户的请求\n\n        client, address = tcp_server.accept()\n        multiprocessing.Process(target=handle_client, args=(client,)).start()\n        # threading.Thread(target=handle_client, args=(client,)).start()\n        # 处理用户的请求\n        client.close()\n\n        # handle_client(client)\n\n\n\n\nif __name__ == '__main__':\n    main()\n```\n##### 协程\n```\n# 初始化套芥子\n# 绑定端口，复用\n# 监听套芥子\n# 循环接受用户的请求\n# 处理用户的请求\nimport gevent\nfrom gevent import monkey\nmonkey.patch_all()\nimport multiprocessing\nimport threading\nimport socket\nimport re\n\nimport time\n\nimport gevent\n\n\ndef handle_client(client):\n    time.sleep(5)\n    data = client.recv(1024).decode(\"utf-8\")\n\n    ret = re.match(r\"[^/]+(/[^ ]*)\\s\", data)\n    if ret:\n        file_path = ret.group(1)\n        if file_path == \"/\":\n            file_path = \"/post.html\"\n    else:\n        client.close()\n        return\n\n\n    with open(\"static%s\"%file_path, 'rb') as f:\n        data = f.read()\n\n    response_line = \"HTTP/1.1 200 ok\\r\\n\".encode('utf-8')\n    response_header = \"content-type:text/html;charset=utf-8\\r\\n\".encode(\"utf-8\")\n    response_None = \"\\r\\n\".encode(\"utf-8\")\n    response_body = data\n    response = response_line + response_header + response_None +response_body\n    client.send(response)\n\n    client.close()\n    print(11111)\n\ndef main():\n\n\n    # 初始化套芥子\n    tcp_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    # 绑定端口，复用\n    tcp_server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)\n    tcp_server.bind(('', 8080))\n\n    # 监听套芥子\n    tcp_server.listen(128)\n    while True:\n        # 循环接受用户的请求\n\n        client, address = tcp_server.accept()\n        gevent.spawn(handle_client, client)\n        # multiprocessing.Process(target=handle_client, args=(client,)).start()\n        # threading.Thread(target=handle_client, args=(client,)).start()\n        # 处理用户的请求\n        # client.close()\n\n        # handle_client(client)\n    tcp_server.close()\n\n\n\n\nif __name__ == '__main__':\n    main()\n```\n\n### http服务器在程序外传参\n####目标\n需要掌握sys.argv知识\n\n1.我们的项目是最终放在服务器中的，没有图形化界面的，如果端口重复，会启动错误\n2.在程序外面传递端口号\n3.在终端运行python3 http服务器程序传参.py 8080启动程序\n\n####案例\n在终端运行python3 http服务器程序传参.py 8080  启动程序\n\n####步骤\n1.需要在程序在终端运行传递端口\n2.判断sys.argv的长度是否是2\n3.判断端口参数是否是纯数字\n4.将接收的端口信息转换成int类型，在创建程序时传递给init初始化\n\n####总结\n1.sys.argv可以在程序外传参是一个列表类型\n2.文件名是列表中的第一个元素\n\n\n####代码\n```\nimport multiprocessing\nimport socket\nimport threading\nimport gevent\nimport sys\nfrom gevent import monkey\nmonkey.patch_all()\nimport re\n\nimport time\n\n\ndef handle_client(client):\n    time.sleep(1)\n\n    data = client.recv(1024).decode(\"utf-8\")\n    print(data)\n    # 1.匹配地址\n    ret = re.match(r\"[^/]+(/[^ ]*)\\s\", data)\n    print(ret.group(1))\n    if ret:\n        file_path = ret.group(1)\n        if file_path == \"/\":\n            file_path = \"/post.html\"\n    else:\n        client.close()\n        return\n    print(file_path)\n    response_line = \"HTTP/1.1 200 ok\\r\\n\"\n    response_header = \"content-type:text/html;charset=utf-8\\r\\n\"\n    response_None = \"\\r\\n\"\n\n    if file_path == \"/post.html\":\n        with open(\"post.html\", 'r') as f:\n            content = f.read()\n        response_body = content\n        response = response_line + response_header + response_None + response_body\n        response = response.encode('utf-8')\n        client.send(response)\n    elif file_path == '/favicon.ico':\n        pass\n\n    else:\n        with open('.%s'%file_path, 'rb') as f:\n            content = f.read()\n        response_body = content\n        response = response_line.encode('utf-8') + response_header.encode('utf-8') + response_None.encode('utf-8') + response_body\n\n        client.send(response)\n    client.close()\n    # 组装响应报文\n\n\nclass Tcp_Server(object):\n    def __init__(self, port):\n        self.tcp_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.tcp_server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)\n        self.tcp_server.bind((\"\", port))\n        self.tcp_server.listen(128)\n\n    def run_server(self):\n        while True:\n            client, address = self.tcp_server.accept()\n            # threading.Thread(target=handle_client, args=(client,)).start()\n            # multiprocessing.Process(target=handle_client, args=(client,)).start()\n            gevent.spawn(handle_client, client)\n            # 这里不需要加入到耗时列表中，因为本身就是耗时的\n            # 需要关闭套接字\n            # handle_client(client)\n\n        self.tcp_server.close()\n\ndef main():\n    if len(sys.argv) != 2:\n        print(\"启动程序格式: python3 08.http服务器传参.py 8080\")\n        return\n    \n    if not sys.argv[1].isdigit():\n        print(\"启动程序格式: python3 08.http服务器传参.py 8080\")\n        return\n\n    port = sys.argv[1]\n    # print(type(port))\n    tcp_server = Tcp_Server(int(port))\n    tcp_server.run_server()\n\n\nif __name__ == '__main__':\n    main()\n```"},{"title":"redis集群搭建","url":"/2019/04/09/redis集群搭建/","content":"## redis集群搭建\n\n###### 集群的概念：集群是一组相互独立的、通过高速网络互联的计算机，它们构成了一个组，并以单一系统的模式加以管理。\n\n###### redis数据库准备：\n\n> 创建文件目录conf/7000.conf(有多少个服务器就键几个，ps:可以在不同机器上创建，主要区别是port、bing（真实主机IP）、pidfile、cluster-config-file)\n\n~~~\nport 7000\nbind 172.16.179.130\ndaemonize yes\npidfile 7000.pid\ncluster-enabled yes\ncluster-config-file 7000_node.conf\ncluster-node-timeout 15000\nappendonly yes\n~~~\n\n> 启动：redis-server 7000.conf（有几个就启动几个）\n\n> 查看进程是否启动：ps -ef | grep redis\n\n###### 创建集群\n\n1. redis的安装包中包含了redis-trib.rb，⽤于创建集群\n\n2. 接下来的操作在172.16.179.130（可以在集群内的任一机器上执行）机器上进⾏\n\n3. 将命令复制，这样可以在任何⽬录下调⽤此命令\n\n   ~~~\n   sudo cp /usr/share/doc/redis-tools/examples/redis-trib.rb /usr/local/bin/\n   ~~~\n\n4. 安装ruby环境，因为redis-trib.rb是⽤ruby开发的\n\n   ~~~\n   sudo apt-get install ruby\n   ~~~\n\n5. 运⾏如下命令创建集群（包含所有创建集群的redis程序）ps：集群会从参与集群的redis程序中选取不少于一半的程序作为主服务器（少于的话整个集群无法提供服务）\n\n   ~~~\n   redis-trib.rb create --replicas 1 172.16.179.130:7000 172.16.179.130:7001 172.16.179.130:7002 172.16.179.131:7003 172.16.179.131:7004 172.16.179.131:7005集群是\n   ~~~\n\n###### 数据怎么决定存在哪个redis上（CRC16）\n\n理解关键点：\n\n+ 去中心化、去中间件 负载均衡\n+ 哈希槽（hash slot）分配、默认16384个槽（solt）、具体算法CRC16(key) % 16384 如果有n个redis master，每个redis master均分16384个槽，而且是连续的\n+ Redis 集群会把数据存在⼀个 master 节点，然后在这个 master 和其对应的salve 之间进⾏数据同步。当读取数据时，也根据⼀致性哈希算法到对应的 master 节 点获取数据。只有当⼀个master 挂掉之后，才会启动⼀个对应的 salve 节点，充 当 master\n+ 需要注意的是：必须要3个或以上的主节点，否则在创建集群时会失败，并且当存 活的主节点数⼩于总节点数的⼀半时，整个集群就⽆法提供服务了\n\n###### redis cluster与python交互\n\n1. 安装依赖包\n\n   ~~~\n   pip install redis-py-cluster\n   ~~~\n\n2. 连接示例\n\n   ~~~python\n   from rediscluster import *\n   if __name__ == '__main__':\n   \ttry:\n       # 构建所有的节点，Redis会使⽤CRC16算法，将键和值写到某个节点上(连接的是集群里面的master节点)\n       startup_nodes = [\n           {'host': '192.168.26.128', 'port': '7000'},\n           {'host': '192.168.26.130', 'port': '7003'},\n           {'host': '192.168.26.128', 'port': '7001'},\n       ]\n       # 构建StrictRedisCluster对象                   \t  \tsrc=StrictRedisCluster(startup_nodes=startup_nodes,decode_responses=True)\n       # 设置键为name、值为itheima的数据\n       result=src.set('name','itheima')\n       print(result)\n       # 获取键为name\n       name = src.get('name')\n       print(name)\n     except Exception as e:\n       print(e)\n   ~~~\n\n   \n\n"},{"title":"mysql的主从同步&&读写分离 （Django）","url":"/2018/11/30/mysql主从&读写分离/","content":"\n# mysql的主从同步&&读写分离 （Django）                                                                                                                                                           \n\n## 主从同步\n\n**定义：**主从同步使得数据可以从一个数据库服务器复制到其他服务器上，在复制数据时，一个服务器充当主服务器（master），其余的服务器充当从服务器（slave）---异步复制、不需要一直连、通过配置文件指定复制内容\n\n**好处：**\n\n+ 提高数据库性能\n+ 提高数据安全\n+ 提高主服务器性能\n\n**同步机制：**\n\n+ 二进制日志\n+ 在使用二进制日志时，主服务器的所有操作都会被记录下来，然后从服务器会接收到该日志的一个副本。从服务器可以指定执行该日志中的哪一类事件（譬如只插入数据或者只更新数据），默认会执行日志中的所有语句。\n+ 每一个从服务器会记录关于二进制日志的信息：文件名和已经处理过的语句，这样意味着不同的从服务器可以分别执行同一个二进制日志的不同部分，并且从服务器可以随时连接或者中断和服务器的连接。\n+ 主服务器和每一个从服务器都必须配置一个唯一的ID号（在my.cnf文件的[mysqld]模块下有一个server-id配置项），另外，每一个从服务器还需要通过CHANGE MASTER TO语句来配置它要连接的主服务器的ip地址，日志文件名称和该日志里面的位置（这些信息存储在主服务器的数据库里）\n\n**基本步骤：**\n\n1. 在主服务器上，必须开启二进制日志机制和配置一个独立的ID\n2. 在每一个从服务器上，配置一个唯一的ID，创建一个用来专门复制主服务器数据的账号\n3. 在开始复制进程前，在主服务器上记录二进制文件的位置信息\n4. 如果在开始复制之前，数据库中已经有数据，就必须先创建一个数据快照（可以使用mysqldump导出数据库，或者直接复制数据文件）\n5. 配置从服务器要连接的主服务器的IP地址和登陆授权，二进制日志文件名和位置\n\n**要点说明（用docker运行从服务器）：**\n\n+ 主从数据库版本尽量相同或版本接近\n\n+ 创建文件夹mysql_slave文件夹，并将mysql配置文件夹mysql.conf.d拷贝到此处，按如下修改\n\n  ~~~\n  port  =  8306\n  general_log  = 0\n  server-id  = 2\n  ~~~\n\n+ 创建docker容器\n\n  ~~~\n  docker run --name mysql-slave -e MYSQL_ROOT_PASSWORD=mysql -d --network=host -v /home/python/mysql_slave/data:/var/lib/mysql -v /home/python/mysql_slave/mysql.conf.d:/etc/mysql/mysql.conf.d  mysql:5.7.22\n  ~~~\n\n+ 测试，在ubuntu中使用mysql命令尝试连接docker容器中的mysql\n\n  ~~~\n  mysql -uroot -pmysql -h 127.0.0.1 --port=8306\n  ~~~\n\n+ 主服务器数据备份（--all-databases ：导出所有数据库、--lock-all-tables ：执行操作时锁住所有表，防止操作时有数据修改）\n\n  ~~~\n  mysqldump -uroot -pmysql --all-databases --lock-all-tables > ~/master_db.sql\n  ~~~\n\n+ 在docker容器中导入数据\n\n  ~~~\n  mysql -uroot -pmysql -h127.0.0.1 --port=8306 < ~/master_db.sql\n  ~~~\n\n+ #### 配置主服务器master（设置log_bin和server-id）\n\n  ~~~\n  sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf\n  ~~~\n\n  ~~~\n  server-id    =1\n  log_bin      =/var/log/mysql/mysql-bin.log\n  ~~~\n\n+ 重启mysql服务\n\n  ~~~\n  sudo service mysql restart\n  ~~~\n\n+ 登入主服务器Ubuntu中的mysql，创建用于从服务器同步数据使用的帐号\n\n  ~~~\n  mysql –uroot –pmysql\n  \n  GRANT REPLICATION SLAVE ON *.* TO 'slave'@'%' identified by 'slave';\n  \n  FLUSH PRIVILEGES;\n  \n  ~~~\n\n+ 获取主服务器的二进制日志信息(File为使用的日志文件名字，Position为使用的文件位置，这两个参数须记下，配置从服务器时会用到)\n\n  ~~~\n  SHOW MASTER STATUS;\n  ~~~\n\n+ #### 配置从服务器slave （docker中的mysql）\n\n  1. 进入docker\n\n     ~~~\n     docker exec -it cd1513c6afce /bin/bash\n     ~~~\n\n  2. 进入docker中的mysql\n\n     ~~~\n     mysql -uroot -pmysql -h 127.0.0.1 --port=8306\n     ~~~\n\n  3. 执行（master_host:主服务器Ubuntu的ip地址、master_log_file: 前面查询到的主服务器日志文件名、master_log_pos: 前面查询到的主服务器日志文件位置）\n\n     ~~~\n     change master to master_host='127.0.0.1', master_user='slave', master_password='slave',master_log_file='mysql-bin.000006', master_log_pos=590;\n     ~~~\n\n  4. 启动slave服务器，并查看同步状态(Slave_IO_Running:Yes、Slave_SQL_Running:Yes)\n\n     ~~~\n     start slave;\n     show slave status \\G\n     ~~~\n\n     \n\n## 配置Django实现读写分离\n\n1. ####  在配置文件中增加slave数据库的配置\n\n   ~~~python\n   DATABASES = {\n       'default': {\n           'ENGINE': 'django.db.backends.mysql',\n           'HOST': '127.0.0.1',  # 数据库主机\n           'PORT': 3306,  # 数据库端口\n           'USER': 'root',  # 数据库用户名\n           'PASSWORD': 'mysql',  # 数据库用户密码\n           'NAME': 'meiduo'  # 数据库名字\n       },\n       'slave': {\n           'ENGINE': 'django.db.backends.mysql',\n           'HOST': '127.0.0.1',  # 数据库主机\n           'PORT': 8306,  # 数据库端口\n           'USER': 'root',  # 数据库用户名\n           'PASSWORD': 'mysql',  # 数据库用户密码\n           'NAME': 'meiduo'  # 数据库名字\n       }\n   }\n   ~~~\n\n2. ### **创建数据库操作的路由分发类**\n\n   ~~~python\n   class MasterSlaveRouter(object):\n       \"\"\"数据库主从读写分离路由\"\"\"\n   \n       def db_for_read(self, model, **hints):\n           \"\"\"读数据库\"\"\"\n           return \"slave\"\n   \n       def db_for_write(self, model, **hints):\n           \"\"\"写数据库\"\"\"\n           return \"default\"\n   \n       def allow_relation(self, obj1, obj2, **hints):\n           \"\"\"是否运行关联操作\"\"\"\n           return True\n   ~~~\n\n3. #### 配置读写分离路由\n\n   ~~~python\n   # 配置读写分离\n   DATABASE_ROUTERS = ['utils.db_router.MasterSlaveRouter']\n   ~~~\n\n   "},{"title":"主从、哨兵、集群区别","url":"/2018/11/28/主从、哨兵、集群区别/","content":"\n**1、** **主从、哨兵、集群区别：**\n\n**a)**       **主从**\n\n​                     **i.**            **默认情况下redis数据库充当slave角色时是只读的不能进行写操作****（ps：可以在配置文件中开启非只读：slave-read-only no）**\n\n​                   **ii.**            **复制的过程原理**\n\n​\t\t\t**1.**       **当从库和主库建立MS关系后，会向主数据库发送SYNC命令**\n\n​\t\t\t**2.**       **主库接收到SYNC命令后会开始在后台保存快照（RDB持久化过程），并将期间接收到的写命令缓存起来；**\n\n​\t\t\t**3.**       **当快照完成后，主Redis会将快照文件和所有缓存的写命令发送给从Redis**\n\n​\t\t\t**4.**       **从Redis接收到后，会载入快照文件并且执行收到的缓存的命令**\n\n​\t\t\t**5.**       **之后，主Redis每当接收到写命令时就会将命令发送从Redis，从而保证数据的一致**\n\n​                  **iii.**            **无磁盘复制**\n\n​\t\t\t**1.**       **Redis****在与从数据库进行复制初始化时将不会将快照存储到磁盘，而是直接通过网络发送给从数据库，避免了IO性能差问题。**\n\n​\t\t\t**2.**       **开启无磁盘复制：repl-diskless-sync yes**\n\n​                  **iv.**            **复制架构中出现宕机情况，怎么办？**\n\n​\t\t\t**1.**       **从Redis宕机**\n\n​\t\t\t\t**a)**       **这个相对而言比较简单，在Redis中从库重新启动后会自动加入到主从架构中，自动完成同步数据**\n\n​\t\t\t\t**b)**       **在Redis2.8版本后就实现了，主从断线后恢复的情况下实现增量复制**\n\n​\t\t\t**2.**       **主Redis宕机**\n\n​\t\t\t\t**a)**       **第一步，在从数据库中执行SLAVEOF NO ONE命令，断开主从关系并且提升为主库继续服务**\n\n​\t\t\t\t**b)**       **第二步，将主库重新启动后，执行SLAVEOF命令，将其设置为其他库的从库，这时数据就能更新回来**\n\n​\t\t\t\t**c)**       **这个手动完成恢复的过程其实是比较麻烦的并且容易出错，有没有好办法解决呢？当前有的，Redis提高的哨兵（sentinel）的功能。**\n\n**b)**       **哨兵（sentinel）**\n\n​                     **i.**            **哨兵的作用就是对Redis的系统的运行情况的监控，它是一个独立进程。它的功能有2个：**\n\n​\t\t\t**1.**       **监控主数据库和从数据库是否运行正常**\n\n​\t\t\t**2.**       **主数据出现故障后自动将从数据库转化为主数据库**\n\n​\t\t\t**3.**       **多个哨兵，不仅同时监控主从数据库，而且哨兵之间互为监控**\n\n​                   **ii.**            **搭建步骤**\n\n​\t\t\t**1.**       **先搭建redis主从，配置主从信息**\n\n​\t\t\t**2.**       **搭建哨兵集群，让哨兵监听主服务器**\n\n​                  **iii.**            **某个主服务器宕机，sentinel会重新设置新的maste，当原来的master重新上线后会自动成为一个slave。**\n\n**c)**       **集群**\n\n​                     **i.**            **架构**\n\n​\t\t\t**1.**       **所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽.**\n\n​\t\t\t**2.**       **节点的fail是通过集群中超过半数的节点检测失效时才生效**\n\n​\t\t\t**3.**       **客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可**\n\n​\t\t\t**4.**       **redis-cluster****把所有的物理节点映射到[0-16383]slot（插槽）上,cluster 负责维护node<->slot<->value**\n\n​                   **ii.**            **插槽的分配**\n\n​\t\t\t**1.**       **./redis-trib.rb** **脚本实现了是将16384个插槽平均分配给了N个节点**\n\n​                  **iii.**            **插槽和key的关系**\n\n​\t\t\t**1.**       **key****的有效部分使用CRC16算法计算出哈希值，再将哈希值对16384取余，得到插槽值**\n\n​                  **iv.**            **故障机制**\n\n​\t\t\t**1.**       **集群中的每个节点都会定期的向其它节点发送PING命令，并且通过有没有收到回复判断目标节点是否下线**\n\n​\t\t\t**2.**       **集群中每一秒就会随机选择5个节点，然后选择其中最久没有响应的节点放PING命令**\n\n​\t\t\t**3.**       **如果一定时间内目标节点都没有响应，那么该节点就认为目标节点疑似下线**\n\n​\t\t\t**4.**       **当集群中的节点超过半数认为该目标节点疑似下线，那么该节点就会被标记为下线**\n\n​\t\t\t**5.**       **当集群中的任何一个节点下线，就会导致插槽区有空档，不完整，那么该集群将不可用**\n\n​\t\t\t**6.**       **如何解决上述问题**\n\n​\t\t\t\t**a)**       **在Redis集群中可以使用主从模式实现某一个节点的高可用**\n\n​\t\t\t\t**b)**       **当该节点（master）宕机后，集群会将该节点的从数据库（slave）转变为（master）继续完成集群服务**"},{"title":"前端学习小札（持续更新）","url":"/2018/03/08/前端学习小札（持续更新）/","content":"## 前端三大块\n\n+ HTML\n+ CSS\n+ JavaScript\n\n## HTML\n\n+ 块元素：在布局中默认会独占一行，宽度默认等于父级的宽度，块元素后的元素需换行排列。\n+ 内联元素：元素之间可以排列在一行，设置宽高无效，它的宽高由内容撑开。\n+ 注释：<!--  注释   -->\n\n## CSS\n\n+ 层叠样式表(Cascading Style Sheets)\n\n+ 引入方式\n\n  + 内联式\n\n  + 嵌入式\n\n  + 外链式\n\n+ 选择器\n\n  + 标签选择器：div{}\n  + 类选择器：.class{}\n  + 层级选择器：div .class{}\n  + id选择器：#id{}\n  + 伪类选择器：.id:hover{}\n\n+ CSS盒子模型\n\n  + content\n  + padding-top\n  + border-top\n  + margrin-top\n\n+ 显示display\n\n  + none：元素隐藏且不占位置\n  + inline：元素以行内元素显示\n  + block：元素以块元素显示\n\n+ 元素溢出（**overflow**）\n\n  + visible ：默认值。内容不会被修剪，会呈现在元素框之外。\n  + hidden ：内容会被修剪，并且其余内容是不可见的。\n  + scroll： 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。\n  + auto ：如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。\n\n+ CSS权重\n\n  + 内联样式：1000\n  + ID选择器：100\n  + 类/伪类：10\n  + 标签选择器：1\n\n### JavaScript\n\n+ JavaScript 是一种弱类型语言，JavaScript的变量类型由它的值来决定。 定义变量需要用关键字 'var'\n\n+ 嵌入页面的方式\n\n  1. 行间事件（主要用于事件）\n\n     ~~~html\n     <input type=\"button\" name=\"\" onclick=\"alert('ok！');\">\n     ~~~\n\n     \n\n  2. 页面script标签嵌入\n\n  3. 外部引入\n\n+ 变量类型\n\n  + 5种基本数据类型\n    1. number\n    2. string\n    3. boolean\n    4. undefined\n    5. null\n  + 1种复合类型：object\n\n+ 注释\n\n  + 单行：//\n  + 多行：/* 注释 */\n\n+ 匈牙利命名风格（首单词小写其他大写）\n\n+ 字符串处理方法\n\n  1. 字符串合并操作：“ + ”\n\n  2. parseInt 将数字字符串转化为整数\n\n  3. parseFloat将数字字符串转化为小数\n\n  4. split把一个字符串分隔成字符串组成的数组\n\n  5. index Of查找字符串是否含有某字符\n\n  6. substring截取字符串 用法： substring(start,end)（不包括end）\n\n  7. 字符串反转\n\n     ~~~javascript\n     var str = 'asdfj12jlsdkf098';\n     var str2 = str.split('').reverse().join('');\n     ~~~\n\n+ 调试程序的方法\n\n  + 输出变量和对象的方法\n    1. alert\n    2. console.log\n    3. document.title\n  + 断点调试：通过chrome浏览器调试工具的sources窗口，可以对外链的js文件进行断点调试\n\n+ 定时器\n\n  1. 定时调用函数\n  2. 制作动画\n\n+ 封闭函数：javascript中匿名函数的另外一种写法，创建一个一开始就执行而不用命名的函数。封闭函数可以创造一个独立的空间，在封闭函数内定义的变量和函数不会影响外部同名的函数和变量，可以避免命名冲突，在页面上引入多个js文件时，用这种方式添加js文件比较安全\n\n### jquery\n\n+ jquery的口号和愿望 Write Less, Do More（写得少，做得多）\n\n+ jquery入口函数简写\n\n  ~~~javascript\n  $(function(){\n  \n       ......\n  \n  });\n  ~~~\n\n+ jquery(选择器)\n\n  ~~~javascript\n  $('#myId') //选择id为myId的网页元素\n  $('.myClass') // 选择class为myClass的元素\n  $('li') //选择所有的li元素\n  $('#ul1 li span') //选择id为为ul1元素下的所有li下的span元素\n  $('input[name=first]') // 选择name属性等于first的input元素\n  ~~~\n\n+ 选择集转移\n\n  ~~~javascript\n  $('#box').prev(); //选择id是box的元素前面紧挨的同辈元素\n  $('#box').prevAll(); //选择id是box的元素之前所有的同辈元素\n  $('#box').next(); //选择id是box的元素后面紧挨的同辈元素\n  $('#box').nextAll(); //选择id是box的元素后面所有的同辈元素\n  $('#box').parent(); //选择id是box的元素的父元素\n  $('#box').children(); //选择id是box的元素的所有子元素\n  $('#box').siblings(); //选择id是box的元素的同级元素\n  $('#box').find('.myClass'); //选择id是box的元素内的class等于myClass的元素\n  ~~~\n\n+ 绑定事件\n\n  + click\n\n    ~~~javascript\n    $('#btn1').click(function(){\n    \n        // 内部的this指的是原生对象\n    \n        // 使用jquery对象用 $(this)\n    \n    })\n    ~~~\n\n    \n\n+ jquery动画：通过animate方法可以设置元素某属性值上的动画，可以设置一个或多个属性值，动画执行完成后会执行一个函数。\n\n+ jquery链式调用\n\n  ~~~javascript\n  $('#div1') // id为div1的元素\n  .children('ul') //该元素下面的ul子元素\n  .slideDown('fast') //高度从零变到实际高度来显示ul元素\n  .parent()  //跳到ul的父元素，也就是id为div1的元素\n  .siblings()  //跳到div1元素平级的所有兄弟元素\n  .children('ul') //这些兄弟元素中的ul子元素\n  .slideUp('fast');  //高度实际高度变换到零来隐藏ul元素\n  ~~~\n\n+ jquery属性操作\n\n  1. html() 取出或设置html内容\n\n     ~~~\n     var $htm = $('#div1').html();\n     ~~~\n\n  2. prop() 取出或设置某个属性的值\n\n     ~~~\n     var $src = $('#img1').prop('src');\n     ~~~\n\n+ jquery事件列表\n\n  ~~~\n  blur() 元素失去焦点\n  focus() 元素获得焦点\n  click() 鼠标单击\n  mouseover() 鼠标进入（进入子元素也触发）\n  mouseout() 鼠标离开（离开子元素也触发）\n  mouseenter() 鼠标进入（进入子元素不触发）\n  mouseleave() 鼠标离开（离开子元素不触发）\n  hover() 同时为mouseenter和mouseleave事件指定处理函数\n  ready() DOM加载完成\n  submit() 用户递交表单\n  ~~~\n\n+ 事件冒泡\n\n  + 事件冒泡机制有时候是不需要的，需要阻止掉，通过 event.stopPropagation() 来阻止\n\n    ~~~javascript\n        $box3.click(function(event) {\n            alert('grandson');\n            event.stopPropagation();\n        });\n    ~~~\n\n+ 阻止默认行为\n\n  + 阻止表单提交\n\n    ```\n    $('#form1').submit(function(event){\n        event.preventDefault();\n    })\n    ```\n\n  + 合并阻止操作\n\n    ~~~javascript\n    // event.stopPropagation();\n    // event.preventDefault();\n    // 合并写法：\n    return false;\n    ~~~\n\n+ 事件委托\n\n+ Dom操作（文档对象模型(Document Object Model)）\n\n  + Dom操作也叫做元素节点操作，它指的是改变html的标签结构，它有两种情况：\n    1. 移动现有标签的位置\n    2. 将新创建的标签插入到现有的标签中\n  + 移动或者插入标签的方法\n    1. append()和appendTo()：在现存元素的内部，从后面放入元素\n    2. prepend()和prependTo()：在现存元素的内部，从前面放入元素\n    3. after()和insertAfter()：在现存元素的外部，从后面放入元素\n    4. before()和insertBefore()：在现存元素的外部，从前面放入元素\n    5. 删除标签：$('#div1').remove();\n\n+ json（JavaScript Object Notation：javascript对象表示法）\n\n+ ajax\n\n  + ajax一个前后台配合的技术，它可以让javascript发送http请求，与后台通信，获取数据和信息。ajax技术的原理是实例化xmlhttp对象，使用此对象与后台通信。jquery将它封装成了一个函数$.ajax()，我们可以直接用这个函数来执行ajax请求。\n\n  + 常用参数：\n\n    1. url 请求地址\n    2. type 请求方式，默认是'GET'，常用的还有'POST'\n    3. dataType 设置返回的数据格式，常用的是'json'格式，也可以设置为'html'\n    4. data 设置发送给服务器的数据\n    5. success 设置请求成功后的回调函数\n    6. error 设置请求失败后的回调函数\n    7. async 设置是否异步，默认值是'true'，表示异步\n\n  + 新写法\n\n    ~~~javascript\n    $.ajax({\n        url: '/change_data',\n        type: 'GET',\n        dataType: 'json',\n        data:{'code':300268}\n    })\n    .done(function(dat) {\n        alert(dat.name);\n    })\n    .fail(function() {\n        alert('服务器超时，请重试！');\n    });\n    ~~~\n\n### vue.js\n\n+ Vue.js是前端三大新框架：Angular.js、React.js、Vue.js之一，Vue.js目前的使用和关注程度在三大框架中稍微胜出，并且它的热度还在递增。\n\n+ 原理：当一个 Vue 实例被创建时，它向 Vue 的响应式系统中加入了其data对象中能找到的所有的属性。当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。还可以在Vue实例中定义方法，通过方法来改变实例中data对象中的数据，数据改变了，视图中的数据也改变。\n\n+ vue指令：\n\n  1. v-bind：缩写:href=\"url\"---对象语法&&数组语法\n\n     ~~~vue\n     <div class=\"static\" v-bind:class=\"{active:isActive,'text-danger':hasError }\"></div>\n     <div class=\"static active\"></div>\n     ~~~\n\n     \n\n  2. v-on：缩写@click=\"fnChangeMsg\"\n\n     ~~~vue\n     <!-- 阻止单击事件继续传播 -->\n     <a v-on:click.stop=\"doThis\"></a>\n     \n     <!-- 提交事件不再重载页面 -->\n     <form v-on:submit.prevent=\"onSubmit\"></form>\n     \n     <!-- 修饰符可以串联 -->\n     <a v-on:click.stop.prevent=\"doThat\"></a>\n     \n     <!-- 只有修饰符 -->\n     <form v-on:submit.prevent></form>\n     ~~~\n\n     \n\n  3. v-if\n\n  4. v-else\n\n  5. v-else-if\n\n  6. v-show：另一个用于根据条件展示元素的选项是 v-show 指令。用法和v-if大致一样，但是它不支持v-else,它和v-if的区别是，它制作元素样式的显示和隐藏，元素一直是存在的\n\n  7. v-for：列表渲染\n\n     ~~~vue\n     <ul id=\"example-1\">\n       <li v-for=\"item in items\">\n         {{ item}}\n       </li>\n     </ul>\n     ~~~\n\n  8. v-model:表单输入绑定，适用于：\n\n     1. 单行文本框\n     2. 多行文本框\n     3. 复选框\n     4. 单选框\n     5. 下拉框\n\n  9. 计算属性和侦听\n\n  10. 过滤器：过滤器实际上是一个函数，可以在一个组件的选项中定义组件内部过滤器\n\n      ~~~vue\n      <!-- 在双花括号中 -->\n      {{ prize | RMB }}\n      <!-- 在v-bind中 -->\n      <div v-bind:id=\"rawId | formatId\"></div>\n      \n      filters:{\n        RMB:function(value){\n          if(value=='')\n          {\n            return;\n          }\n          return '¥ '+value;\n        }\n      }\n      ~~~\n\n+ 实例的生命周期\n\n  1. beforeCreate\n  2. created\n  3. beforeMount\n  4. mounted：实例挂载到dom之后被调用，可以当成是vue对象的ready方法来使用，一般用它来做dom的初始化操作。\n  5. beforeUpdate：数据发生变化前调用\n  6. updated：数据发生变化后调用\n\n+ axios完整写法\n\n  ~~~vue\n  axios({\n    method: 'post',\n    url: '/user/12345',\n    data: {\n      firstName: 'Fred',\n      lastName: 'Flintstone'\n    }\n  })\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n  ~~~\n\n+ 简写\n\n  ~~~\n  axios.post('/user', {\n    firstName: 'Fred',\n    lastName: 'Flintstone'\n  })\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n  ~~~\n\n### ES6语法\n\n+ 变量声明let（一般变量）和const（常量）\n+ 箭头函数\n+ 模块导入import和导出export\n+ 对象简写（host）\n\n### AngularJS\n\n+ ng-app ：指令告诉 AngularJS，<div> 元素是 AngularJS 应用程序 的\"所有者\"\n\n+ ng-model ：指令把输入域的值绑定到应用程序变量 name。\n\n+ ng-bind： 指令把应用程序变量 name 绑定到某个段落的 innerHTML。\n\n+ ng-init ：指令初始化 AngularJS 应用程序变量。\n\n+ AngularJS 模块\n\n  ~~~javascript\n  var app = angular.module('myApp', []);\n  ~~~\n\n+ AngularJS 控制器\n\n  ~~~javascript\n  app.controller('myCtrl', function($scope) {\n      $scope.firstName= \"John\";\n      $scope.lastName= \"Doe\";\n  });\n  ~~~\n\n+ ng-repeat：重复一个 HTML 元素（对比v-for）\n\n  ~~~\n  <div ng-app=\"\" ng-init=\"names=['Jani','Hege','Kai']\">\n    <p>使用 ng-repeat 来循环数组</p>\n    <ul>\n      <li ng-repeat=\"x in names\">\n        {{ x }}\n      </li>\n    </ul>\n  </div>\n  ~~~\n\n+ 创建自定义的指令：使用驼峰法来命名一个指令， runoobDirective, 但在使用它时需要以 **-** 分割, runoob-directive\n\n  ~~~html\n  <body ng-app=\"myApp\">\n  \n  <runoob-directive></runoob-directive>\n  \n  <script>\n  var app = angular.module(\"myApp\", []);\n  app.directive(\"runoobDirective\", function() {\n      return {\n          template : \"<h1>自定义指令!</h1>\"\n      };\n  });\n  </script>\n  \n  </body>\n  ~~~\n\n+ ng-model 指令根据表单域的状态添加/移除以下类\n\n  1. ng-empty\n  2. ng-not-empty\n  3. ng-touched\n  4. ng-untouched\n  5. ng-valid\n  6. ng-invalid\n  7. ng-dirty\n  8. ng-pending\n  9. ng-pristine\n\n+ scope 是模型。Scope(作用域) 是应用在 HTML (视图) 和 JavaScript (控制器)之间的纽带。scope 是一个 JavaScript 对象，带有属性和方法，这些属性和方法可以在视图和控制器中使用。\n\n+ 所有的应用都有一个 $rootScope，它可以作用在 ng-app 指令包含的所有 HTML 元素中。\n\n+ 实例\n\n  ~~~html\n  <div ng-app=\"myApp\" ng-controller=\"personCtrl\">\n  \n  名: <input type=\"text\" ng-model=\"firstName\"><br>\n  姓: <input type=\"text\" ng-model=\"lastName\"><br>\n  <br>\n  姓名: {{fullName()}}\n  \n  </div>\n  \n  <script>\n  var app = angular.module('myApp', []);\n  app.controller('personCtrl', function($scope) {\n      $scope.firstName = \"John\";\n      $scope.lastName = \"Doe\";\n      $scope.fullName = function() {\n          return $scope.firstName + \" \" + $scope.lastName;\n      }\n  });\n  </script>\n  ~~~\n\n+ $http（对比ajax&&axios）\n\n  + **$http** 是 AngularJS 中的一个核心服务，用于读取远程服务器的数据\n\n  + 实例\n\n    ~~~\n    // 简单的 GET 请求，可以改为 POST\n    $http({\n        method: 'GET',\n        url: '/someUrl'\n    }).then(function successCallback(response) {\n            // 请求成功执行代码\n        }, function errorCallback(response) {\n            // 请求失败执行代码\n    });\n    # 简写\n    $http.get('/someUrl', config).then(successCallback, errorCallback);\n    $http.post('/someUrl', data, config).then(successCallback, errorCallback);\n    ~~~\n\n  + 实例二\n\n    ~~~\n    var app = angular.module('myApp', []);\n        \n    app.controller('siteCtrl', function($scope, $http) {\n        $http({\n            method: 'GET',\n            url: 'https://www.runoob.com/try/angularjs/data/sites.php'\n        }).then(function successCallback(response) {\n                $scope.names = response.data.sites;\n            }, function errorCallback(response) {\n                // 请求失败执行代码\n        });\n      \n    });\n    ~~~\n\n+ 事件\n\n  + ng-click\n  + ng-hide\n  + ng-show\n\n+ 生命周期\n\n  1. ngOnChanges - 当数据绑定输入属性的值发生变化时调用\n  2. ngOnInit - 在第一次 ngOnChanges 后调用\n  3. ngDoCheck - 自定义的方法，用于检测和处理值的改变\n  4. ngAfterContentInit - 在组件内容初始化之后调用\n  5. ngAfterContentChecked - 组件每次检查内容时调用\n  6. ngAfterViewInit - 组件相应的视图初始化之后调用\n  7. ngAfterViewChecked - 组件每次检查视图时调用\n  8. ngOnDestroy - 指令销毁前调用\n\n### React.js\n\n+ React 是一个用于构建用户界面的 JAVASCRIPT 库。\n+ **React主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）**。\n+ React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源。\n+ React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。\n\n~~~html\n<body>\n<div id=\"example\"></div>\n<script type=\"text/babel\">\nfunction Clock(props) {\n  return (\n    <div>\n      <h1>Hello, world!</h1>\n      <h2>现在是 {props.date.toLocaleTimeString()}</h2>\n    </div>\n  );\n}\n\nfunction tick() {\n  ReactDOM.render(\n    <Clock date={new Date()} />,\n    document.getElementById('example')\n  );\n}\n\nsetInterval(tick, 1000);\n</script>\n</body>\n~~~\n\n+ React JSX\n\n  ~~~\n  const element = <h1>Hello, world!</h1>;\n  ~~~\n\n+ 这种看起来可能有些奇怪的标签语法既不是字符串也不是 HTML。\n\n+ 它被称为 JSX， 一种 JavaScript 的语法扩展。 我们推荐在 React 中使用 \n\n+ JSX 来描述用户界面。\n\n+ JSX 是在 JavaScript 内部实现的。\n\n+ 我们知道元素是构成 React 应用的最小单位，JSX 就是用来声明 React 当中的元素。\n\n+ 与浏览器的 DOM 元素不同，React 当中的元素事实上是普通的对象，React DOM 可以确保 浏览器 DOM 的数据内容与 React 元素保持一致。\n\n+ 要将 React 元素渲染到根 DOM 节点中，我们通过把它们都传递给 ReactDOM.render() 的方法来将其渲染到页面上\n\n+ 样式\n\n  ~~~\n  var myStyle = {\n      fontSize: 100,\n      color: '#FF0000'\n  };\n  ReactDOM.render(\n      <h1 style = {myStyle}>菜鸟教程</h1>,\n      document.getElementById('example')\n  );\n  ~~~\n\n+ 注释需要写在花括号中\n\n+ 数组\n\n  ~~~\n  var arr = [\n    <h1>菜鸟教程</h1>,\n    <h2>学的不仅是技术，更是梦想！</h2>,\n  ];\n  ReactDOM.render(\n    <div>{arr}</div>,\n    document.getElementById('example')\n  );\n  ~~~\n\n+ 组件\n\n  ~~~\n  function Name(props) {\n      return <h1>网站名称：{props.name}</h1>;\n  }\n  function Url(props) {\n      return <h1>网站地址：{props.url}</h1>;\n  }\n  function Nickname(props) {\n      return <h1>网站小名：{props.nickname}</h1>;\n  }\n  function App() {\n      return (\n      <div>\n          <Name name=\"菜鸟教程\" />\n          <Url url=\"http://www.runoob.com\" />\n          <Nickname nickname=\"Runoob\" />\n      </div>\n      );\n  }\n   \n  ReactDOM.render(\n       <App />,\n      document.getElementById('example')\n  );\n  ~~~\n\n+ 生命周期\n\n  1. Mounting：已插入真实 DOM\n  2. Updating：正在被重新渲染\n  3. Unmounting：已移出真实 DOM\n\n+ react AJAX\n\n  + React 组件的数据可以通过 componentDidMount 方法中的 Ajax 来获取，当从服务端获取数据时可以将数据存储在 state 中，再用 this.setState 方法重新渲染 UI。\n  + 当使用异步加载数据时，在组件卸载前使用 componentWillUnmount 来取消未完成的请求。\n\n  ~~~\n  class UserGist extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {username: '', lastGistUrl: ''};\n    }\n   \n   \n    componentDidMount() {\n      this.serverRequest = $.get(this.props.source, function (result) {\n        var lastGist = result[0];\n        this.setState({\n          username: lastGist.owner.login,\n          lastGistUrl: lastGist.html_url\n        });\n      }.bind(this));\n    }\n   \n    componentWillUnmount() {\n      this.serverRequest.abort();\n    }\n   \n    render() {\n      return (\n        <div>\n          {this.state.username} 用户最新的 Gist 共享地址：\n          <a href={this.state.lastGistUrl}>{this.state.lastGistUrl}</a>\n        </div>\n      );\n    }\n  }\n   \n  ReactDOM.render(\n    <UserGist source=\"https://api.github.com/users/octocat/gists\" />,\n    document.getElementById('example')\n  );\n  ~~~\n\n  \n\n\n\n"},{"title":"python学习小札（持续更新）","url":"/2018/01/15/python学习小札（持续更新）/","content":"\n## list排序高级\n\n~~~python\nstus=[\n    (1,2,3),\n    (2,3,4),\n    {\"name\": \"wangwu\", \"age\": 17}\n]\nstus.sort(key=lambda x:x[2])\nprint(stus)\n~~~\n\n+ key后面用匿名函数来指定排序规则，x指的是list里面的各个元素，x[2]表示根据x元素下标为2的那个元素排序，所以如果要用这种方式排序，list里面的元素样式要一致\n\n---\n\n## 列表推导式\n\n+ 生成元组列表\n\n  ~~~python\n  [(x,y) for x in range(1,3) for y in range(3)]\n  ~~~\n\n+ 生成字典列表\n\n  ~~~\n  [{x:y} for x in range(1,3) for y in range(3)]\n  ~~~\n\n---\n\n## python 标准库\n\n+ 文件操作\n\n  ~~~python\n  import os\n  os.rename\n  os.remove\n  os.os.getcwd\n  os.listdir\n  \n  ~~~\n\n---\n\n## 魔法方法\n\n+ \\_\\_init\\_\\_\n\n+ _\\_str\\_\\_\n\n+ _\\_del\\_\\_：当删除对象时，python解释器也会默认调用一个方法，这个方法为`__del__()`方法\n\n+ _\\_new\\_\\_：创建出一个没有被初始化的对象、`__init__`有一个参数self，就是这个`__new__`返回的实例，`__init__`在`__new__`的基础上可以完成一些其它初始化的动作，`__init__`不需要返回值\n\n+ _\\_all\\_\\_：import \\*  的时候，除了all里面的其他不会被导入\n\n+ _\\_doc\\_\\_：当使用 help 函数时，help函数会通过__doc__魔法属性将参数中的 DocString 属性展示出来。\n\n+ _\\_module\\_\\_：查看当前成员属于哪个模块\n\n+ _\\_class\\_\\_：查看对象属于哪个类\n\n+ _\\_bases\\_\\_：查看本类的父类有哪些\n\n+ _\\_mro\\_\\_：查看类中方法的查找顺序\n\n+ _\\_dict\\_\\_：在类和对象中都存在，保存了类或对象的成员信息\n\n+ _\\___call__\\_\\_：通过 callable() 函数，可以判断一个对象是否可以被调用。\n\n  + 在类中实现 __call__ 方法，使自定义类的实例对象成为可调用对象。\n  + __call__ 方法的使用，可以实现类装饰器\n  + 仿函数\n\n+ _\\_setitem\\_\\_、_\\_getitem\\_\\_、_\\_delitem\\_\\_、_\\_len\\_\\_：实现类的下标访问\n\n+ _\\_str\\_\\_：实现自定义对象的显示方式\n\n+ _\\_dict\\_\\_\n\n+ super语法：依照 __mro__ 中的顺序来初始化父类，每个父类只初始化一遍\n\n  ~~~python\n  # 完整\n  super(CurrentClassName, self).__init__(*args, **kwargs)\n  # 简写\n   super().__init__() \n  ~~~\n\n  \n\n---\n\n## 面向对象三大特性\n\n+ 封装\n+ 继承\n+ 多态\n  1. 多态以 **继承** 和 **重写** 父类方法 为前提\n  2. 多态是调用方法的技巧，不会影响到类的内部设计\n\n---\n\n## 类属性\n\n+ 类属性就是 **类对象** 所拥有的属性，它被 **该类的所有实例对象 所共有**\n+ 类属性可以使用 **类对象** 或 **实例对象** 访问\n+ **类属性** 为全类所共有 ，**仅占用一份内存**，**更加节省内存空间**。\n+ 注意点\n  1.  **尽量避免类属性和对象属性同名**。如果有同名对象属性，**实例对象会优先访问对象属性**\n  2. **类属性只能通过类对象修改，不能通过实例对象修改**\n  3. 类属性也可以设置为 **私有**，前边添加两个下划线\n\n---\n\n## 类方法\n\n+ **类对象所拥有的方法**\n+ 需要用装饰器`@classmethod`来标识其为类方法，对于类方法，**第一个参数必须是类对象**，一般以`cls`作为第一个参数。\n\n## 静态方法\n\n+ 需要通过装饰器`@staticmethod`来进行修饰，**静态方法既不需要传递类对象也不需要传递实例对象（形参没有self/cls）**。\n+ 静态方法 也能够通过 **实例对象** 和 **类对象** 去访问\n+ 使用场景\n  1. 当方法中 **既不需要使用实例对象**(如实例对象，实例属性)，**也不需要使用类对象** (如类属性、类方法、创建实例等)时，定义静态方法\n  2. **取消不需要的参数传递**，有利于 **减少不必要的内存占用和性能消耗**\n\n---\n\n## 单例模式\n\n~~~python\n# 实例化一个单例\nclass Singleton(object):\n    __instance = None\n\n    def __new__(cls, age, name):\n        #如果类属性__instance的值为None，\n        #那么就创建一个对象，并且赋值为这个对象的引用，保证下次调用这个方法时\n        #能够知道之前已经创建过对象了，这样就保证了只有1个对象\n        if not cls.__instance:\n            cls.__instance = object.__new__(cls)\n        return cls.__instance\n~~~\n\n---\n\n## Vim三种基本模式\n\n+ 命令模式\n+ 编辑模式\n+ 末行模式\n\n---\n\n## 并行&&并发\n\n+ 并行：指的是任务数小于等于cpu核数，即任务真的是一起执行的\n+ 并发：指的是任务数多余cpu核数，通过操作系统的各种任务调度算法，实现用多个任务“一起”执行（实际上总有一些任务不在执行，因为切换任务的速度相当快，看上去一起执行而已）\n\n---\n\n## 多任务编程\n\n+ 线程\n\n  1. 线程就是在程序运行过程中，执行程序代码的一个分支，每个运行的程序至少都有一个线程\n\n  2. 只有线程启动，线程才会加入到活动线程列表\n\n  3. 线程执行之间是无序的\n\n  4. 主线程会等待所有的子线程结束后才结束，如果需要可以设置守护主线程\n\n  5. 多线程共享全局变量，很方便在多个线程间共享数据\n\n  6. 线程同步解决资源竞争问题，不过会变成单任务\n\n     ~~~python\n     # 启动线程\n     first_thread.start()\n     # 主线程等待第一个线程执行完成以后代码再继续执行，让其执行第二个线程\n     # 线程同步： 一个任务执行完成以后另外一个任务才能执行，同一个时刻只有一个任务在执行\n     first_thread.join()\n     # 启动线程\n     second_thread.start()\n     ~~~\n\n  7. 互斥锁： 对共享数据进行锁定，保证同一时刻只能有一个线程去操作。\n\n     + 具体那个线程抢到这个锁我们决定不了，是由cpu调度决定的。\n\n     + 确保了某段关键代码只能由一个线程从头到尾完整地执行\n\n     + 多线程执行变成了包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了\n\n     + 锁使用不好就容易出现死锁情况\n\n     + 上锁解锁过程\n\n       + 当一个线程调用锁的acquire()方法获得锁时，锁就进入“locked”状态。\n       + 每次只有一个线程可以获得锁。如果此时另一个线程试图获得这个锁，该线程就会变为“blocked”状态，称为“阻塞”，直到拥有锁的线程调用锁的release()方法释放锁之后，锁进入“unlocked”状态。\n       + 线程调度程序从处于同步阻塞状态的线程中选择一个来获得锁，并使得该线程进入运行（running）状态。\n\n       ~~~python\n       # 创建锁\n       mutex = threading.Lock()\n       # 锁定\n       mutex.acquire()\n       # 释放\n       mutex.release()\n       ~~~\n\n       \n\n+ 进程\n\n  + 进程是操作系统资源分配的基本单位\n\n  + 一个进程默认有一个线程，进程里面可以创建线程，线程是依附在进程里面的，没有进程就没有线程。\n\n  + 进程的状态：新建---就绪---（等待/阻塞）---运行--死亡\n\n  + 进程间不共享全局变量：创建子进程其实是对主进程进行拷贝，进程之间相互独立，访问的全局变量不是同一个，所以进程之间不共享全局变量\n\n  + 主进程会等待所有的子进程执行完成以后程序再退出\n\n  + 创建步骤：\n\n    1. 创建子进程\n\n    2. （设置守护进程，主进程退出后自动销毁所有子进程）\n\n    3. 启动进程\n\n    4. 主动销毁子进程\n\n       ~~~\n       work_process.terminate()\n       ~~~\n\n  + 进程间通信\n\n    + Queue（子进程间）、socket（AF_UNIX：本地，AF_INET（Ipv4）/AF_INET6(ipv6)：互联网）\n\n  + 进程池\n\n    + 同步进程池：\n\n      1. 一个任务执行完成以后另外一个任务才能\n      2. 步骤：创建进程池，指定最大进程数---添加任务（apply）\n\n    + 异步进程池\n\n      1. 进程池中的进程同时执行任务，进程之间不会等待\n\n      2. 步骤：创建进程池，指定最大进程数---添加任务（apply_async）---关闭进程池，意思告诉主进程以后不会有新的任务添加进来----主进程等待进程池执行完成以后程序再退出\n\n         ~~~python\n         # 创建进程池\n         # 3:进程池中进程的最大个数\n         pool = multiprocessing.Pool(3)\n         # 模拟大批量的任务，让进程池去执行\n         for i in range(5):\n         \t# 循环让进程池执行对应的work任务\n             # 同步执行任务，一个任务执行完成以后另外一个任务才能执行\n             # pool.apply(work)\n             # 异步执行，任务执行不会等待，多个任务一起执行\n             pool.apply_async(work)\n         # 关闭进程池，意思告诉主进程以后不会有新的任务添加进来\n         pool.close()\n         # 主进程等待进程池执行完成以后程序再退出\n         pool.join()\n         ~~~\n\n+ 进程和线程总结：进程是操作系统资源分配的基本单位，线程是CPU调度的基本单位\n\n+ 协程（称微线程，纤程,也称为用户级线程）\n\n  + 在不开辟线程的基础上完成多任务，也就是在单线程的情况下完成多任务，多个任务按照一定顺序交替执行 通俗理解只要在def里面只看到一个yield关键字表示就是协程\n\n  + greenlet（手动切换switch）\n\n  + gevent：gevent内部封装的greenlet，其原理是当一个greenlet遇到**IO**(指的是input output 输入输出，比如网络、文件操作等)操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。\n\n    1. 打补丁\n\n       ~~~\n       from gevent import monkey\n       # 打补丁，让gevent框架识别耗时操作，比如：time.sleep，网络请求延时\n       monkey.patch_all()\n       #创建协程指定对应的任务\n       g1 = gevent.spawn(work1, 3)\n       # 主线程等待协程执行完成以后程序再退出\n       g1.join()\n       ~~~\n\n       \n\n---\n\n## 多任务编程\n\n### UDP（ (User Datagram Protocol) ）\n\n+ 优点：传输快、64K、无连接、开销小\n\n+ 缺点：不可靠、无流量监控\n\n+ 发送数据\n\n  1. 创建套接字\n\n  2. 发送消息\n\n  3. 关闭套接字\n\n  4. 广播设置\n\n     ~~~python\n     # 创建udpsocket\n     udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n     # 设置socket的选项，允许发送广播消息\n     udp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, True)\n     # 发送广播消息\n     udp_socket.sendto(\"大家好，我叫小郭同学，多多关照!\".encode(\"gbk\"), (\"255.255.255.255\", 9090))\n     # 关闭socket\n     udp_socket.close()\n     ~~~\n\n     \n\n+ 接收信息\n\n  1. 创建套接字\n  2. 绑定端口\n  3. 接收消息\n  4. 关闭套接字\n\n### socket\n\n+ socket(简称 套接字) 是进程间通信一个工具，它能实现把数据从一方传输到另外一方，完成不同电脑上进程之间的通信， 它好比数据的搬运工。\n\n  ~~~python\n  import socket\n  socket.socket(AddressFamily, Type)\n  ~~~\n\n+ Address Family：IP地址类型; AF_INET表示ipv4类型、AF_INET6表示ipv6类型; AF_UNIX:本机传输数据，不经过网关\n\n+ AF_INET需经过多个协议层的编解码，消耗系统cpu，并且数据传输需要经过网卡，受到网卡带宽的限制。AF_UNIX数据到达内核缓冲区后，由内核根据指定路径名找到接收方socket对应的内核缓冲区，直接将数据拷贝过去，不经过协议层编解码，节省系统cpu，并且不经过网卡，因此不受网卡带宽的限制。\n\n### TCP(Transmission Control Protocol)\n\n+ 一种面向连接的、可靠的、基于字节流的传输层通信协议.\n+ TCP采用发送应答机制：三次握手和4次挥手\n+ 超时重传\n+ 错误校验\n+ 流量监控和阻塞管理\n+ 发送消息\n  1. 创建套接字\n  2. 连接服务器\n  3. 发送数据\n  4. 关闭套接字\n+ 接收消息\n  1. 创建套接字\n  2. 绑定地址端口\n  3. 设置监听（使用socket创建的套接字默认的属性是主动的，使用listen将其变为被动的，这样就可以接收别人的链接了）\n  4. 创建子套接字处理请求\n  5. 用子套接字接收数据\n  6. 处理完关闭套接字\n\n### 迭代器\n\n+ 迭代：在类里面提供一个`__iter__`创建的对象是可迭代对象，可迭代对象是需要迭代器完成数据迭代的\n\n+ 可迭代对象：使用for循环遍历取值的**对象**叫做可迭代对象, 比如：列表、元组、字典、集合、range、字符串\n\n+ 自定义迭代器对象：在类里面定义`__iter__`和`__next__`方法创建的对象就是迭代器对象\n\n  ~~~python\n  from collections import Iterable\n  from collections import Iterator\n  \n  # 自定义可迭代对象: 在类里面定义__iter__方法创建的对象就是可迭代对象\n  class MyList(object):\n  \n      def __init__(self):\n          self.my_list = list()\n  \n      # 添加指定元素\n      def append_item(self, item):\n          self.my_list.append(item)\n  \n      def __iter__(self):\n          # 可迭代对象的本质：遍历可迭代对象的时候其实获取的是可迭代对象的迭代器， 然后通过迭代器获取对象中的数据\n          my_iterator = MyIterator(self.my_list)\n          return my_iterator\n  \n  \n  # 自定义迭代器对象: 在类里面定义__iter__和__next__方法创建的对象就是迭代器对象\n  class MyIterator(object):\n  \n      def __init__(self, my_list):\n          self.my_list = my_list\n  \n          # 记录当前获取数据的下标\n          self.current_index = 0\n  \n          # 判断当前对象是否是迭代器\n          result = isinstance(self, Iterator)\n          print(\"MyIterator创建的对象是否是迭代器:\", result)\n  \n      def __iter__(self):\n          return self\n  \n      # 获取迭代器中下一个值\n      def __next__(self):\n          if self.current_index < len(self.my_list):\n              self.current_index += 1\n              return self.my_list[self.current_index - 1]\n          else:\n              # 数据取完了，需要抛出一个停止迭代的异常\n              raise StopIteration\n  \n  \n  my_list = MyList()\n  my_list.append_item(1)\n  my_list.append_item(2)\n  result = isinstance(my_list, Iterable)\n  \n  print(result)\n  \n  for value in my_list:\n      print(value)\n  ~~~\n\n+ 小结：迭代器的作用就是是记录当前数据的位置以便获取下一个位置的值\n\n### 生成器\n\n+ 生成器是一类特殊的迭代器,它不需要再像上面的类一样写`__iter__()和__next__()`方法了, 使用更加方便,它依然可以使用next函数和for循环取值\n+ 创建生成器的方法\n  + 把一个列表生成式的 [ ] 改成 ( )\n  + 在def函数里面看到有yield关键字那么就是生成器\n+ 生成器创建有两种方式，一般都使用yield关键字方法创建生成器\n+ yield特点是代码执行到yield会暂停，把结果返回出去，再次启动生成器在暂停的位置继续往下执行\n\n### 正则\n\n+ ## \\num\n\n  ~~~python\n  # 匹配出<html>hh</html>\n  re.match(\"<([a-zA-Z1-6]+)>.*</\\\\1>\", \"<html>hh</html>\")\n  ~~~\n\n+ ## `(?P<name>)` `(?P=name)`\n\n  ~~~python\n  re.match(\"<(?P<name1>[a-zA-Z1-6]+)><(?P<name2>[a-zA-Z1-6]+)>.*</(?P=name2)></(?P=name1)>\", \"<html><h1>www.itcast.cn</h1></html>\")\n  ~~~\n\n+ search：匹配出第一个\n\n+ findall：匹配出所有，返回列表\n\n+ sub：替换（可以指定替换次数）\n\n+ split：根据匹配进行切割字符串，并返回一个列表\n\n  ~~~python\n  # maxsplit=1 分割次数， 默认全部分割\n  result = re.split(\",|:\", my_str, maxsplit=1)\n  print(result)\n  # ['貂蝉', '杨玉环:西施,王昭君']\n  ~~~\n\n+ r 表示原生字符串，数据里面的反斜杠不需要进行转义，针对的只是反斜杠\n\n### 网络传输-TCP/IP四层模型\n\n+ 应用层（HTTP、FTP）\n+ 传输层（TCP、UDP）\n+ 网络层（IP）\n+ 网络接口层\n+ HTTP协议的工作模式是一次请求(request)和一次响应(response)的模式\n\n### GIL（Global Interpreter Lock）\n\n+ GIL 只在CPython 解释器上存在。\n+ 互斥锁和 GIL 锁都是用来解决多个线程中的共享变量的竞争资源问题。\n+ 缺点：无法充分利用多核cpu\n+ 优点：Python解释在程序遇到IO等待时，会释放 GIL 锁\n+ 解决办法：可以使用多进程+协程替代多线程实现多任务\n\n### with（上下文管理器）\n\n+ 上下文管理器背后工作的机制是使用Python的方法：**enter**和**exit**。\n\n  ~~~python\n  import time\n  \n  class MyOpen(object):\n  \tdef __init__(self,file, mode):\n  \t\tself.__file = file\n  \t\tself.__mode = mode\n  \n  \tdef __enter__(self):\n  \t\tprint('__enter__ run ... 打开文件')\n  \t\tself.__handle = open(self.__file, self.__mode)\n  \t\treturn self.__handle\n  \n  \tdef __exit__(self, exc_type, exc_val, exc_tb):\n  \t\tprint('__exit__... run ... 关闭文件')\n  \t\tself.__handle.close()\n  with MyOpen('test','w') as f:\n  \tf.write('Python 大法好')\n  \ttime.sleep(3)\n  \n  print('over')\n  ~~~\n\n### 闭包\n\n+ nonlocal：在闭包的内部函数中直接使用外部函数的变量时，不需要任何操作，直接使用就可以了。但是如果要修改外部变量的值，需要将变量声明为 nonlocal\n\n+ 类装饰器：\n\n  ~~~python\n  class Test(object):\n      # 通过初始化方法，将要被装饰的函数传进来并记录下来\n      def __init__(self, func):\n          self.__func = func\n      # 重写 __call__ 方法来实现装饰内容\n      def __call__(self, *args, **kwargs):\n          print('wrapper context')\n              self.__func(*args, **kwargs)\n  ~~~\n\n+ 多个装饰器装饰一个函数：就近原则\n\n+ 带参装饰器执行过程\n\n  1. 先执行 set_args('参数') 得到 set_args 函数中的返回值,也就是 set_fun 函数的引用\n  2. 然后返回的引用和 @ 进行组合,变成装饰器形式 **@set_fun** , 但是这时 set_fun 函数因为是返回的闭包引用,所以保留了args的参数值\n  3. 再调用 show 的时候, show 还是指向的 wrapper 函数，但是在这个函数中，可以使用外面两层函数的变量或参数\n  4. 无论在何时，闭包有几层，最终被装饰的函数永远指向 wrapper 函数\n\n  ~~~python\n  # 定义带参数的装饰器\n  def set_args(string):\n      print('args_func')\n      def set_fun(func):\n          print('set_func')\n          def wrapper(*args,**kwargs):\n              print('hello_' + string)\n              return func(*args,**kwargs)\n          return wrapper\n      return set_fun\n  \n  # 利用装饰器来装饰函数\n  @set_args('world')\n  def show():\n      print('show')\n  \n  # 调用函数\n  show()\n  ~~~\n\n### MySQL\n\n+ 视图\n\n+ 索引\n\n+ 事务\n\n+ 用户管理\n\n  + 创建帐户、授权\n\n  + 语法：grant 权限列表 on 数据库 to '用户名'@'访问主机' identified by '密码'\n\n    ~~~sql\n    -- 加入testuser用户，密码123123，只能\b对jddb中的表做查询操作\n    grant select on jddb.* to 'testuser'@'localhost' identified by '123123';\n    -- 将testuser权限改为对所有库有所有权限 \n    grant all privileges on *.* to 'testuser'@'localhost' with grant option;\n    update user set authentication_string=password('新密码') where user='用户名';\n    ~~~\n\n    "}]